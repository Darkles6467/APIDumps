#pragma once

#include "BaseDeclarations.h"
#include "UObject.h"
#include "UObjectBaseUtility.h"
#include "UObjectBase.h"
#include "FOverlapResult.h"
#include "FHitResult.h"
#include "AActor.h"
#include "FAvailableMission.h"
#include "AShooterCharacter.h"
#include "FDinoSetupGroup.h"
#include "FKey.h"
#include "FLocalizedSoundCueEntry.h"
#include "FLocalizedSoundWaveAnimTexturePairArrays.h"
#include "FDinoSetup.h"
#include "AMissionType_ModularMissionBase.h"
#include "FPenetrationTraceHit.h"
#include "APrimalStructure.h"
#include "FOverlappedFoliageElement.h"
#include "FMultiUseEntry.h"
#include "UPrimalColorSet.h"

struct UVictoryCoreHighest : UObject
{

	// Functions

};

struct UVictoryCore : UVictoryCoreHighest
{

	// Functions

	static bool OverlappingActors(UWorld * theWorld, TArray<FOverlapResult> * Overlaps, FVector Origin, float Radius, int CollisionGroups, AActor * InIgnoreActor, FName TraceName, bool bComplexOverlapTest) { return NativeCall<bool, UWorld *, TArray<FOverlapResult> *, FVector, float, int, AActor *, FName, bool>(nullptr, "UVictoryCore.OverlappingActors", theWorld, Overlaps, Origin, Radius, CollisionGroups, InIgnoreActor, TraceName, bComplexOverlapTest); }
	static FVector2D * ProjectWorldToScreenPosition(FVector2D * result, const FVector * WorldLocation, APlayerController * ThePC) { return NativeCall<FVector2D *, FVector2D *, const FVector *, APlayerController *>(nullptr, "UVictoryCore.ProjectWorldToScreenPosition", result, WorldLocation, ThePC); }
	static FString * FormatSecondsAsHoursMinutesSeconds(FString * result, unsigned int Seconds) { return NativeCall<FString *, FString *, unsigned int>(nullptr, "UVictoryCore.FormatSecondsAsHoursMinutesSeconds", result, Seconds); }
	static bool OverlappingActorsTrace(UWorld * theWorld, TArray<FOverlapResult> * Overlaps, FVector Origin, float Radius, ECollisionChannel TraceChannel, AActor * InIgnoreActor, FName TraceName, bool bComplexOverlapTest) { return NativeCall<bool, UWorld *, TArray<FOverlapResult> *, FVector, float, ECollisionChannel, AActor *, FName, bool>(nullptr, "UVictoryCore.OverlappingActorsTrace", theWorld, Overlaps, Origin, Radius, TraceChannel, InIgnoreActor, TraceName, bComplexOverlapTest); }
	static void DestroyWidget(UWidget * WidgetToDestroy) { NativeCall<void, UWidget *>(nullptr, "UVictoryCore.DestroyWidget", WidgetToDestroy); }
	static int RandInt(int MaxVal) { return NativeCall<int, int>(nullptr, "UVictoryCore.RandInt", MaxVal); }
	static int GetWeightedRandomIndex(const TArray<float> * pArray, float ForceRand) { return NativeCall<int, const TArray<float> *, float>(nullptr, "UVictoryCore.GetWeightedRandomIndex", pArray, ForceRand); }
	static FString * StripEmptyUnicode(FString * result, const FString * InText, int maxChars) { return NativeCall<FString *, FString *, const FString *, int>(nullptr, "UVictoryCore.StripEmptyUnicode", result, InText, maxChars); }
	static FString * StripNewlineCharacters(FString * result, const FString * InText) { return NativeCall<FString *, FString *, const FString *>(nullptr, "UVictoryCore.StripNewlineCharacters", result, InText); }
	static FVector2D * ProjectWorldToScreenPositionRaw(FVector2D * result, const FVector * WorldLocation, APlayerController * ThePC) { return NativeCall<FVector2D *, FVector2D *, const FVector *, APlayerController *>(nullptr, "UVictoryCore.ProjectWorldToScreenPositionRaw", result, WorldLocation, ThePC); }
	static FName * GetObjectPath(FName * result, UObject * Obj) { return NativeCall<FName *, FName *, UObject *>(nullptr, "UVictoryCore.GetObjectPath", result, Obj); }
	static FVector * RandomLocationInRadius(FVector * result, const FVector * Center, const float RadiusMax, const float RadiusMin) { return NativeCall<FVector *, FVector *, const FVector *, const float, const float>(nullptr, "UVictoryCore.RandomLocationInRadius", result, Center, RadiusMax, RadiusMin); }
	static UPhysicalMaterial * TracePhysMaterial(UWorld * theWorld, FVector StartPos, FVector EndPos, AActor * IgnoreActor) { return NativeCall<UPhysicalMaterial *, UWorld *, FVector, FVector, AActor *>(nullptr, "UVictoryCore.TracePhysMaterial", theWorld, StartPos, EndPos, IgnoreActor); }
	static bool ActorHasLineOfSight(AActor * FromActor, AActor * ToActor, AActor ** OutBlockingActor, FVector ToActorOffset, ECollisionChannel Channel, float DebugDrawDuration) { return NativeCall<bool, AActor *, AActor *, AActor **, FVector, ECollisionChannel, float>(nullptr, "UVictoryCore.ActorHasLineOfSight", FromActor, ToActor, OutBlockingActor, ToActorOffset, Channel, DebugDrawDuration); }
	static bool ActorHasLineOfSightToWorldLocation(AActor * FromActor, FVector ToLocation, AActor ** OutBlockingActor, ECollisionChannel Channel, float DebugDrawDuration) { return NativeCall<bool, AActor *, FVector, AActor **, ECollisionChannel, float>(nullptr, "UVictoryCore.ActorHasLineOfSightToWorldLocation", FromActor, ToLocation, OutBlockingActor, Channel, DebugDrawDuration); }
	static void AddActorToCustomActorList(UWorld * ForWorld, FName SearchCustomTag, AActor * ActorToAdd, bool createListIfMissing) { NativeCall<void, UWorld *, FName, AActor *, bool>(nullptr, "UVictoryCore.AddActorToCustomActorList", ForWorld, SearchCustomTag, ActorToAdd, createListIfMissing); }
	static void AddToActorList(UWorld * ForWorld, int ActorListNum, AActor * ActorRef) { NativeCall<void, UWorld *, int, AActor *>(nullptr, "UVictoryCore.AddToActorList", ForWorld, ActorListNum, ActorRef); }
	static void AddToEditorMessageLog(UObject * WorldContextObject, FString Message, TEnumAsByte<enum EEditorMessageLogLevel::Type> LogLevel, bool bServerOnly) { NativeCall<void, UObject *, FString, TEnumAsByte<enum EEditorMessageLogLevel::Type>, bool>(nullptr, "UVictoryCore.AddToEditorMessageLog", WorldContextObject, Message, LogLevel, bServerOnly); }
	static void AdjustScreenPositionWithScreenDPI(UWorld * theWorld, FVector2D * ScreenPosition) { NativeCall<void, UWorld *, FVector2D *>(nullptr, "UVictoryCore.AdjustScreenPositionWithScreenDPI", theWorld, ScreenPosition); }
	static bool AreRotatorsNearlyEqual(const FRotator * RotatorA, const FRotator * RotatorB, float WithinError) { return NativeCall<bool, const FRotator *, const FRotator *, float>(nullptr, "UVictoryCore.AreRotatorsNearlyEqual", RotatorA, RotatorB, WithinError); }
	static bool AreTransformsNearlyEqual(const FTransform * TransformA, const FTransform * TransformB, float WithinError) { return NativeCall<bool, const FTransform *, const FTransform *, float>(nullptr, "UVictoryCore.AreTransformsNearlyEqual", TransformA, TransformB, WithinError); }
	static bool AreVector2DsEqual(const FVector2D * VectorA, const FVector2D * VectorB) { return NativeCall<bool, const FVector2D *, const FVector2D *>(nullptr, "UVictoryCore.AreVector2DsEqual", VectorA, VectorB); }
	static bool AreVector2DsNearlyEqual(const FVector2D * VectorA, const FVector2D * VectorB, float WithinError) { return NativeCall<bool, const FVector2D *, const FVector2D *, float>(nullptr, "UVictoryCore.AreVector2DsNearlyEqual", VectorA, VectorB, WithinError); }
	static bool AreVectorsNearlyEqual(const FVector * VectorA, const FVector * VectorB, float WithinError) { return NativeCall<bool, const FVector *, const FVector *, float>(nullptr, "UVictoryCore.AreVectorsNearlyEqual", VectorA, VectorB, WithinError); }
	static float BPFLerp(float InMin, float InMax, float InPercent, bool bClampToMin, bool bClampToMax) { return NativeCall<float, float, float, float, bool, bool>(nullptr, "UVictoryCore.BPFLerp", InMin, InMax, InPercent, bClampToMin, bClampToMax); }
	static float BPFLerpFast(float InMin, float InMax, float InPercent) { return NativeCall<float, float, float, float>(nullptr, "UVictoryCore.BPFLerpFast", InMin, InMax, InPercent); }
	static bool BPFastTrace(UWorld * theWorld, FVector TraceEnd, FVector TraceStart, AActor * ActorToIgnore, float DebugDrawDuration) { return NativeCall<bool, UWorld *, FVector, FVector, AActor *, float>(nullptr, "UVictoryCore.BPFastTrace", theWorld, TraceEnd, TraceStart, ActorToIgnore, DebugDrawDuration); }
	static FString * BPFormatAsTime(FString * result, int InTime, bool UseLeadingZero, bool bForceLeadingZeroHour, bool bShowSeconds) { return NativeCall<FString *, FString *, int, bool, bool, bool>(nullptr, "UVictoryCore.BPFormatAsTime", result, InTime, UseLeadingZero, bForceLeadingZeroHour, bShowSeconds); }
	static FString * BPFormatAsTimeLong(FString * result, int InTime) { return NativeCall<FString *, FString *, int>(nullptr, "UVictoryCore.BPFormatAsTimeLong", result, InTime); }
	static float BPGetBiomeTemperature(ABiomeZoneVolume * BiomeZoneVolume, float GlobalTemperature) { return NativeCall<float, ABiomeZoneVolume *, float>(nullptr, "UVictoryCore.BPGetBiomeTemperature", BiomeZoneVolume, GlobalTemperature); }
	static float BPGetBiomeWind(ABiomeZoneVolume * BiomeZoneVolume, float GlobalWind) { return NativeCall<float, ABiomeZoneVolume *, float>(nullptr, "UVictoryCore.BPGetBiomeWind", BiomeZoneVolume, GlobalWind); }
	static FString * BPGetPrimaryMapName(FString * result, UWorld * WorldContext) { return NativeCall<FString *, FString *, UWorld *>(nullptr, "UVictoryCore.BPGetPrimaryMapName", result, WorldContext); }
	static int BPGetWeightedRandomIndex(const TArray<float> * pArray, float ForceRand) { return NativeCall<int, const TArray<float> *, float>(nullptr, "UVictoryCore.BPGetWeightedRandomIndex", pArray, ForceRand); }
	static bool BPIsDinoIDEqual(const int FirstDinoID1, const int FirstDinoID2, const int SecondDinoID1, const int SecondDinoID2) { return NativeCall<bool, const int, const int, const int, const int>(nullptr, "UVictoryCore.BPIsDinoIDEqual", FirstDinoID1, FirstDinoID2, SecondDinoID1, SecondDinoID2); }
	static bool BPIsTemplate(UObject * AnObject) { return NativeCall<bool, UObject *>(nullptr, "UVictoryCore.BPIsTemplate", AnObject); }
	static FVector2D * BPProjectWorldToScreenPosition(FVector2D * result, const FVector * WorldLocation, APlayerController * ThePC) { return NativeCall<FVector2D *, FVector2D *, const FVector *, APlayerController *>(nullptr, "UVictoryCore.BPProjectWorldToScreenPosition", result, WorldLocation, ThePC); }
	static bool BPProjectWorldToScreenPositionRaw(APlayerController * ThePC, FVector WorldLocation, FVector2D * Out_ScreenLocation, FVector * Out_ViewLocation, bool * Out_bIsScreenLocationInsideViewRect, bool bIgnoreScreenProjectionGlobalTransform) { return NativeCall<bool, APlayerController *, FVector, FVector2D *, FVector *, bool *, bool>(nullptr, "UVictoryCore.BPProjectWorldToScreenPositionRaw", ThePC, WorldLocation, Out_ScreenLocation, Out_ViewLocation, Out_bIsScreenLocationInsideViewRect, bIgnoreScreenProjectionGlobalTransform); }
	static FRotator * BPRTransform(FRotator * result, const FRotator * R, const FRotator * RBasis) { return NativeCall<FRotator *, FRotator *, const FRotator *, const FRotator *>(nullptr, "UVictoryCore.BPRTransform", result, R, RBasis); }
	static FRotator * BPRTransformInverse(FRotator * result, const FRotator * R, const FRotator * RBasis) { return NativeCall<FRotator *, FRotator *, const FRotator *, const FRotator *>(nullptr, "UVictoryCore.BPRTransformInverse", result, R, RBasis); }
	static FRotator * BPRotatorLerp(FRotator * result, const FRotator * A, const FRotator * B, const float * Alpha) { return NativeCall<FRotator *, FRotator *, const FRotator *, const FRotator *, const float *>(nullptr, "UVictoryCore.BPRotatorLerp", result, A, B, Alpha); }
	static bool BPSweepComponent(UPrimitiveComponent * Component, FHitResult * OutHit, const FVector Start, const FVector End, float Radius, float HalfHeight, FVector Extent, bool bTraceComplex) { return NativeCall<bool, UPrimitiveComponent *, FHitResult *, const FVector, const FVector, float, float, FVector, bool>(nullptr, "UVictoryCore.BPSweepComponent", Component, OutHit, Start, End, Radius, HalfHeight, Extent, bTraceComplex); }
	static void BoxFromOriginAndExtent(FVector Origin, FVector Extent, FVector * OutBoxMin, FVector OutBoxMax) { NativeCall<void, FVector, FVector, FVector *, FVector>(nullptr, "UVictoryCore.BoxFromOriginAndExtent", Origin, Extent, OutBoxMin, OutBoxMax); }
	static FIntPoint * CalculateGPSCoordinates(FIntPoint * result, UWorld * ForWorld, const FVector * WorldPos) { return NativeCall<FIntPoint *, FIntPoint *, UWorld *, const FVector *>(nullptr, "UVictoryCore.CalculateGPSCoordinates", result, ForWorld, WorldPos); }
	static bool CalculateInterceptPosition(const FVector * StartPosition, const FVector * StartVelocity, float ProjectileVelocity, const FVector * TargetPosition, const FVector * TargetVelocity, FVector * InterceptPosition) { return NativeCall<bool, const FVector *, const FVector *, float, const FVector *, const FVector *, FVector *>(nullptr, "UVictoryCore.CalculateInterceptPosition", StartPosition, StartVelocity, ProjectileVelocity, TargetPosition, TargetVelocity, InterceptPosition); }
	static void CallGlobalLevelEvent(UWorld * forWorld, FName EventName) { NativeCall<void, UWorld *, FName>(nullptr, "UVictoryCore.CallGlobalLevelEvent", forWorld, EventName); }
	static bool CanSpawnCustomDino(UWorld * World, FVector * OutCalculatedSpawnLocation, const FVector * PlayerLocation, const FVector * SpawnLocation, const FRotator * SpawnRotation, const FDinoSetup * DinoSetup, float DebugDrawDuration, bool bDoLosCheck, bool bDoExtraSafetyChecks, APrimalCharacter * spawningCharacter, bool bDoOverlapCheck) { return NativeCall<bool, UWorld *, FVector *, const FVector *, const FVector *, const FRotator *, const FDinoSetup *, float, bool, bool, APrimalCharacter *, bool>(nullptr, "UVictoryCore.CanSpawnCustomDino", World, OutCalculatedSpawnLocation, PlayerLocation, SpawnLocation, SpawnRotation, DinoSetup, DebugDrawDuration, bDoLosCheck, bDoExtraSafetyChecks, spawningCharacter, bDoOverlapCheck); }
	static bool CanTeleport(APrimalDinoCharacter * target) { return NativeCall<bool, APrimalDinoCharacter *>(nullptr, "UVictoryCore.CanTeleport", target); }
	static bool CapsuleOverlapFast(UObject * WorldContextObject, AActor ** OutFirstOverlappedActor, const FVector * Origin, const FRotator * CapsuleRotation, float Radius, float HalfHeight, TEnumAsByte<enum ECollisionChannel> CollisionChannel, bool bTraceComplex, bool bIgnoreSelf, AActor * IgnoreActor, bool bDebugDraw, float DebugDrawDuration, bool bBlockingOnly) { return NativeCall<bool, UObject *, AActor **, const FVector *, const FRotator *, float, float, TEnumAsByte<enum ECollisionChannel>, bool, bool, AActor *, bool, float, bool>(nullptr, "UVictoryCore.CapsuleOverlapFast", WorldContextObject, OutFirstOverlappedActor, Origin, CapsuleRotation, Radius, HalfHeight, CollisionChannel, bTraceComplex, bIgnoreSelf, IgnoreActor, bDebugDraw, DebugDrawDuration, bBlockingOnly); }
	static bool CapsuleSweepFast(UObject * WorldContextObject, FHitResult * OutHit, const FVector * Start, const FVector * End, const FRotator * CapsuleRot, float Radius, float HalfHeight, TEnumAsByte<enum ECollisionChannel> CollisionChannel, bool bTraceComplex, bool bIgnoreSelf, const TArray<AActor *> * IgnoreActors, bool bDebugDraw, float DebugDrawDuration) { return NativeCall<bool, UObject *, FHitResult *, const FVector *, const FVector *, const FRotator *, float, float, TEnumAsByte<enum ECollisionChannel>, bool, bool, const TArray<AActor *> *, bool, float>(nullptr, "UVictoryCore.CapsuleSweepFast", WorldContextObject, OutHit, Start, End, CapsuleRot, Radius, HalfHeight, CollisionChannel, bTraceComplex, bIgnoreSelf, IgnoreActors, bDebugDraw, DebugDrawDuration); }
	static bool CapsuleSweepFast(UObject * WorldContextObject, FHitResult * OutHit, const FVector * Start, const FVector * End, const FRotator * CapsuleRot, float Radius, float HalfHeight, TEnumAsByte<enum ECollisionChannel> CollisionChannel, bool bTraceComplex, bool bIgnoreSelf, AActor * IgnoreActor, bool bDebugDraw, float DebugDrawDuration) { return NativeCall<bool, UObject *, FHitResult *, const FVector *, const FVector *, const FRotator *, float, float, TEnumAsByte<enum ECollisionChannel>, bool, bool, AActor *, bool, float>(nullptr, "UVictoryCore.CapsuleSweepFast", WorldContextObject, OutHit, Start, End, CapsuleRot, Radius, HalfHeight, CollisionChannel, bTraceComplex, bIgnoreSelf, IgnoreActor, bDebugDraw, DebugDrawDuration); }
	static bool CapsuleSweepMulti(UObject * WorldContextObject, TArray<FHitResult> * OutHits, const FVector * Start, const FVector * End, const FRotator * CapsuleRot, float Radius, float HalfHeight, const TArray<AActor *> * IgnoreActors, bool bIgnoreSelf, TEnumAsByte<enum ECollisionChannel> CollisionChannel, bool bTraceComplex, bool bDebugDraw, float DebugDrawDuration, bool bFindInitialOverlaps) { return NativeCall<bool, UObject *, TArray<FHitResult> *, const FVector *, const FVector *, const FRotator *, float, float, const TArray<AActor *> *, bool, TEnumAsByte<enum ECollisionChannel>, bool, bool, float, bool>(nullptr, "UVictoryCore.CapsuleSweepMulti", WorldContextObject, OutHits, Start, End, CapsuleRot, Radius, HalfHeight, IgnoreActors, bIgnoreSelf, CollisionChannel, bTraceComplex, bDebugDraw, DebugDrawDuration, bFindInitialOverlaps); }
	static bool CapsuleSweepProjectileArc(UObject * WorldContextObject, const FProjectileArc * Arc, const FRotator * CapsuleRotation, float CapsuleRadius, float CapsuleHalfHeight, bool bRotateCapsuleAlongPath, bool bTraceComplex, FHitResult * OutHitResult, FVector * OutEndLocation, float * OutEndArcTime, float MaxArcLength, const TArray<AActor *> * ActorsToIgnore, bool bIgnoreSelf, float ArcTimeStep, TEnumAsByte<enum ECollisionChannel> CollisionChannel, bool bDrawDebug, float DebugDrawDuration) { return NativeCall<bool, UObject *, const FProjectileArc *, const FRotator *, float, float, bool, bool, FHitResult *, FVector *, float *, float, const TArray<AActor *> *, bool, float, TEnumAsByte<enum ECollisionChannel>, bool, float>(nullptr, "UVictoryCore.CapsuleSweepProjectileArc", WorldContextObject, Arc, CapsuleRotation, CapsuleRadius, CapsuleHalfHeight, bRotateCapsuleAlongPath, bTraceComplex, OutHitResult, OutEndLocation, OutEndArcTime, MaxArcLength, ActorsToIgnore, bIgnoreSelf, ArcTimeStep, CollisionChannel, bDrawDebug, DebugDrawDuration); }
	static FLinearColor * ChangeSaturation(FLinearColor * result, const FLinearColor * InColor, float NewSaturation) { return NativeCall<FLinearColor *, FLinearColor *, const FLinearColor *, float>(nullptr, "UVictoryCore.ChangeSaturation", result, InColor, NewSaturation); }
	static TArray<FString> * ChunkFStringIntoArray(TArray<FString> * result, FString InputString, int ChunkSize) { return NativeCall<TArray<FString> *, TArray<FString> *, FString, int>(nullptr, "UVictoryCore.ChunkFStringIntoArray", result, InputString, ChunkSize); }
	static FVector * ClampLocation(FVector * result, FVector BaseLocation, FVector DesiredLocation, float MaxDiff, bool bTraceClampLocation, UWorld * TraceWorld, const FVector * TraceFromLocation) { return NativeCall<FVector *, FVector *, FVector, FVector, float, bool, UWorld *, const FVector *>(nullptr, "UVictoryCore.ClampLocation", result, BaseLocation, DesiredLocation, MaxDiff, bTraceClampLocation, TraceWorld, TraceFromLocation); }
	static float ClampRotAxis(float BaseAxis, float DesiredAxis, float MaxDiff) { return NativeCall<float, float, float, float>(nullptr, "UVictoryCore.ClampRotAxis", BaseAxis, DesiredAxis, MaxDiff); }
	static FString * ClassToStringReference(FString * result, TSubclassOf<UObject> ForClass) { return NativeCall<FString *, FString *, TSubclassOf<UObject>>(nullptr, "UVictoryCore.ClassToStringReference", result, ForClass); }
	static bool ClipLineInsideBox(const FVector Origin, const FVector Extent, const FVector LineStart, const FVector LineEnd, FVector * OutLineStart, FVector * OutLineEnd) { return NativeCall<bool, const FVector, const FVector, const FVector, const FVector, FVector *, FVector *>(nullptr, "UVictoryCore.ClipLineInsideBox", Origin, Extent, LineStart, LineEnd, OutLineStart, OutLineEnd); }
	static bool ComponentBoundsEncompassesPoint(UPrimitiveComponent * Comp, const FVector * Point, float BoundsMultiplier) { return NativeCall<bool, UPrimitiveComponent *, const FVector *, float>(nullptr, "UVictoryCore.ComponentBoundsEncompassesPoint", Comp, Point, BoundsMultiplier); }
	static FString * ConsumeBonusItemCode(FString * result) { return NativeCall<FString *, FString *>(nullptr, "UVictoryCore.ConsumeBonusItemCode", result); }
	static FVector_NetQuantizeNormal * Conv_VectorToVectorNetQuantize(FVector_NetQuantizeNormal * result, FVector InVector) { return NativeCall<FVector_NetQuantizeNormal *, FVector_NetQuantizeNormal *, FVector>(nullptr, "UVictoryCore.Conv_VectorToVectorNetQuantize", result, InVector); }
	static FString * ConvertIntToStringWithCommas(FString * result, int GivenNumber) { return NativeCall<FString *, FString *, int>(nullptr, "UVictoryCore.ConvertIntToStringWithCommas", result, GivenNumber); }
	static FRotator * ConvertRotatorFromLocalToWorld(FRotator * result, const FRotator * ConvertRot, const FRotator * FromParentRotation) { return NativeCall<FRotator *, FRotator *, const FRotator *, const FRotator *>(nullptr, "UVictoryCore.ConvertRotatorFromLocalToWorld", result, ConvertRot, FromParentRotation); }
	static FRotator * ConvertRotatorFromWorldToLocal(FRotator * result, const FRotator * ConvertRot, const FRotator * ToParentRotation) { return NativeCall<FRotator *, FRotator *, const FRotator *, const FRotator *>(nullptr, "UVictoryCore.ConvertRotatorFromWorldToLocal", result, ConvertRot, ToParentRotation); }
	static float CooldownTimeRemaining(UObject * WorldContextObject, long double CooldownClock, float CooldownDuration) { return NativeCall<float, UObject *, long double, float>(nullptr, "UVictoryCore.CooldownTimeRemaining", WorldContextObject, CooldownClock, CooldownDuration); }
	static void CopyDinoColorSetIndicies(const APrimalDinoCharacter * src, APrimalDinoCharacter * dest) { NativeCall<void, const APrimalDinoCharacter *, APrimalDinoCharacter *>(nullptr, "UVictoryCore.CopyDinoColorSetIndicies", src, dest); }
	static int CountCharactersResolvingGroundLocationInSphere(UWorld * WorldContext, const FVector * location, float radius) { return NativeCall<int, UWorld *, const FVector *, float>(nullptr, "UVictoryCore.CountCharactersResolvingGroundLocationInSphere", WorldContext, location, radius); }
	static long double DateTimeToSeconds(const FDateTime * DateTimeValue) { return NativeCall<long double, const FDateTime *>(nullptr, "UVictoryCore.DateTimeToSeconds", DateTimeValue); }
	static void DeactivateMissionForPlayerCharacter(AShooterCharacter * playerPawn, bool bOverrideForcePreventLeavingMissions) { NativeCall<void, AShooterCharacter *, bool>(nullptr, "UVictoryCore.DeactivateMissionForPlayerCharacter", playerPawn, bOverrideForcePreventLeavingMissions); }
	static void DebugDrawProjectileArc(UObject * WorldContextObject, const FProjectileArc * Arc, float MaxArcTime, float ArcTimeStep, FLinearColor LineColor, float LineThickness, float DebugDrawDuration) { NativeCall<void, UObject *, const FProjectileArc *, float, float, FLinearColor, float, float>(nullptr, "UVictoryCore.DebugDrawProjectileArc", WorldContextObject, Arc, MaxArcTime, ArcTimeStep, LineColor, LineThickness, DebugDrawDuration); }
	static void DeferredSpawnAndFireProjectile_Finish(AShooterProjectile * TheProjectile, FTransform SpawnTransform) { NativeCall<void, AShooterProjectile *, FTransform>(nullptr, "UVictoryCore.DeferredSpawnAndFireProjectile_Finish", TheProjectile, SpawnTransform); }
	static void DestroyAllCharactersWithinMissionTileVolumes(UWorld * theWorld, bool bOnlyCheckForDeadCharacters, FName ForceOnTileStreamVolumeCustomTag) { NativeCall<void, UWorld *, bool, FName>(nullptr, "UVictoryCore.DestroyAllCharactersWithinMissionTileVolumes", theWorld, bOnlyCheckForDeadCharacters, ForceOnTileStreamVolumeCustomTag); }
	static void DisableGCM(AActor * targetActor) { NativeCall<void, AActor *>(nullptr, "UVictoryCore.DisableGCM", targetActor); }
	static int ECC_TO_BITFIELD_BP(ECollisionChannel ConvertChannel) { return NativeCall<int, ECollisionChannel>(nullptr, "UVictoryCore.ECC_TO_BITFIELD_BP", ConvertChannel); }
	static FVector * EvalProjectileArc(FVector * result, UObject * WorldContextObject, const FProjectileArc * Arc, float Time) { return NativeCall<FVector *, FVector *, UObject *, const FProjectileArc *, float>(nullptr, "UVictoryCore.EvalProjectileArc", result, WorldContextObject, Arc, Time); }
	static FString * FindLocalizedVersionOfFilename(FString * result, const FStringAssetReference * OriginalFile) { return NativeCall<FString *, FString *, const FStringAssetReference *>(nullptr, "UVictoryCore.FindLocalizedVersionOfFilename", result, OriginalFile); }
	static FName * FindSocketClosestToDirection(FName * result, USkeletalMeshComponent * Mesh, FVector TargetDirection, const TArray<FName> * Sockets, TArray<float> * OutDotProducts, bool bOnlySocketsWithPrefix, FString SocketPrefix) { return NativeCall<FName *, FName *, USkeletalMeshComponent *, FVector, const TArray<FName> *, TArray<float> *, bool, FString>(nullptr, "UVictoryCore.FindSocketClosestToDirection", result, Mesh, TargetDirection, Sockets, OutDotProducts, bOnlySocketsWithPrefix, SocketPrefix); }
	static bool FindValidLocationInFrontOfTarget(FVector * OutLocation, APrimalCharacter * SourceCharacter, APrimalCharacter * TargetCharacter, float DistanceMargin, TEnumAsByte<enum ECollisionChannel> CollisionChannel, bool bFailIfLocationNotOnGround, AActor * ActorToIgnore, bool bTraceComplex, float DebugDrawDuration) { return NativeCall<bool, FVector *, APrimalCharacter *, APrimalCharacter *, float, TEnumAsByte<enum ECollisionChannel>, bool, AActor *, bool, float>(nullptr, "UVictoryCore.FindValidLocationInFrontOfTarget", OutLocation, SourceCharacter, TargetCharacter, DistanceMargin, CollisionChannel, bFailIfLocationNotOnGround, ActorToIgnore, bTraceComplex, DebugDrawDuration); }
	static bool FindValidLocationNextToTarget(UObject * WorldContextObject, FVector * OutLocation, APrimalCharacter * SourceCharacter, APrimalCharacter * TargetCharacter, float DistanceMargin, int MaxTraceCount, AActor * ActorToIgnore, bool bTraceComplex, bool bDrawDebug, float DebugDrawDuration) { return NativeCall<bool, UObject *, FVector *, APrimalCharacter *, APrimalCharacter *, float, int, AActor *, bool, bool, float>(nullptr, "UVictoryCore.FindValidLocationNextToTarget", WorldContextObject, OutLocation, SourceCharacter, TargetCharacter, DistanceMargin, MaxTraceCount, ActorToIgnore, bTraceComplex, bDrawDebug, DebugDrawDuration); }
	static bool FindWorldActors(UWorld * fWorld, TArray<AActor *> * fContainer, TSubclassOf<AActor> fType, FName fTag) { return NativeCall<bool, UWorld *, TArray<AActor *> *, TSubclassOf<AActor>, FName>(nullptr, "UVictoryCore.FindWorldActors", fWorld, fContainer, fType, fTag); }
	static void FinishSpawning(AActor * Actor) { NativeCall<void, AActor *>(nullptr, "UVictoryCore.FinishSpawning", Actor); }
	static FVector * FlattenDirectionVector(FVector * result, FVector Direction) { return NativeCall<FVector *, FVector *, FVector>(nullptr, "UVictoryCore.FlattenDirectionVector", result, Direction); }
	static FVector * FlattenDirectionVectorInLocalSpace(FVector * result, FVector Direction, FRotator Rotation) { return NativeCall<FVector *, FVector *, FVector, FRotator>(nullptr, "UVictoryCore.FlattenDirectionVectorInLocalSpace", result, Direction, Rotation); }
	static long double FloatToDouble(float val) { return NativeCall<long double, float>(nullptr, "UVictoryCore.FloatToDouble", val); }
	static void ForceDeleteUObject(UObject ** ObjectPointer) { NativeCall<void, UObject **>(nullptr, "UVictoryCore.ForceDeleteUObject", ObjectPointer); }
	static void ForceLevelStreamingToBlock(UWorld * ForWorld, float ForTime) { NativeCall<void, UWorld *, float>(nullptr, "UVictoryCore.ForceLevelStreamingToBlock", ForWorld, ForTime); }
	static void ForceScreenColorFade(UObject * WorldContextObject, FLinearColor FadeColor, float FullOpacityInterval, float TheFadeOutInterval) { NativeCall<void, UObject *, FLinearColor, float, float>(nullptr, "UVictoryCore.ForceScreenColorFade", WorldContextObject, FadeColor, FullOpacityInterval, TheFadeOutInterval); }
	static FString * FormatAsTime(FString * result, int InTime, bool UseLeadingZero, bool bForceLeadingZeroHour, bool bShowSeconds) { return NativeCall<FString *, FString *, int, bool, bool, bool>(nullptr, "UVictoryCore.FormatAsTime", result, InTime, UseLeadingZero, bForceLeadingZeroHour, bShowSeconds); }
	static FString * FormatAsTimeLong(FString * result, int InTime) { return NativeCall<FString *, FString *, int>(nullptr, "UVictoryCore.FormatAsTimeLong", result, InTime); }
	static FString * FuseChunkedFString(FString * result, TArray<FString> InputStringArray) { return NativeCall<FString *, FString *, TArray<FString>>(nullptr, "UVictoryCore.FuseChunkedFString", result, InputStringArray); }
	static FString * Generate_UUID(FString * result) { return NativeCall<FString *, FString *>(nullptr, "UVictoryCore.Generate_UUID", result); }
	static TArray<FAvailableMission> * GetAllAvailableMissions(TArray<FAvailableMission> * result, UWorld * World) { return NativeCall<TArray<FAvailableMission> *, TArray<FAvailableMission> *, UWorld *>(nullptr, "UVictoryCore.GetAllAvailableMissions", result, World); }
	static TArray<FName> * GetAllAvailableMissionsAsTags(TArray<FName> * result, UWorld * World) { return NativeCall<TArray<FName> *, TArray<FName> *, UWorld *>(nullptr, "UVictoryCore.GetAllAvailableMissionsAsTags", result, World); }
	static void GetAllClassesOfType(TArray<TSubclassOf<UObject>> * Subclasses, TSubclassOf<UObject> ParentClass, bool bAllowAbstract, FString Path) { NativeCall<void, TArray<TSubclassOf<UObject>> *, TSubclassOf<UObject>, bool, FString>(nullptr, "UVictoryCore.GetAllClassesOfType", Subclasses, ParentClass, bAllowAbstract, Path); }
	static TArray<AShooterCharacter *> * GetAllLocalPlayerCharacters(TArray<AShooterCharacter *> * result, UObject * WorldContextObject) { return NativeCall<TArray<AShooterCharacter *> *, TArray<AShooterCharacter *> *, UObject *>(nullptr, "UVictoryCore.GetAllLocalPlayerCharacters", result, WorldContextObject); }
	static TArray<AShooterPlayerController *> * GetAllLocalPlayerControllers(TArray<AShooterPlayerController *> * result, UObject * WorldContextObject) { return NativeCall<TArray<AShooterPlayerController *> *, TArray<AShooterPlayerController *> *, UObject *>(nullptr, "UVictoryCore.GetAllLocalPlayerControllers", result, WorldContextObject); }
	static float GetAngleBetweenVectors(const FVector * VectorA, const FVector * VectorB, const FVector * AroundAxis) { return NativeCall<float, const FVector *, const FVector *, const FVector *>(nullptr, "UVictoryCore.GetAngleBetweenVectors", VectorA, VectorB, AroundAxis); }
	static float GetAngleBetweenVectorsPure(FVector VectorA, FVector VectorB, FVector AroundAxis) { return NativeCall<float, FVector, FVector, FVector>(nullptr, "UVictoryCore.GetAngleBetweenVectorsPure", VectorA, VectorB, AroundAxis); }
	static TArray<int> * GetArrayIndicesSorted_Double(TArray<int> * result, const TArray<double> * Array, bool bSortLowToHigh) { return NativeCall<TArray<int> *, TArray<int> *, const TArray<double> *, bool>(nullptr, "UVictoryCore.GetArrayIndicesSorted_Double", result, Array, bSortLowToHigh); }
	static TArray<int> * GetArrayIndicesSorted_Float(TArray<int> * result, const TArray<float> * Array, bool bSortLowToHigh) { return NativeCall<TArray<int> *, TArray<int> *, const TArray<float> *, bool>(nullptr, "UVictoryCore.GetArrayIndicesSorted_Float", result, Array, bSortLowToHigh); }
	static TArray<int> * GetArrayIndicesSorted_Int(TArray<int> * result, const TArray<int> * Array, bool bSortLowToHigh) { return NativeCall<TArray<int> *, TArray<int> *, const TArray<int> *, bool>(nullptr, "UVictoryCore.GetArrayIndicesSorted_Int", result, Array, bSortLowToHigh); }
	static FName * GetBlockingMissionTag(FName * result, AShooterPlayerController * FromPC, FName MissionTag) { return NativeCall<FName *, FName *, AShooterPlayerController *, FName>(nullptr, "UVictoryCore.GetBlockingMissionTag", result, FromPC, MissionTag); }
	static bool GetCharacterCapsuleSize(TSubclassOf<APrimalCharacter> CharClass, float * OutCapsuleRadius, float * OutCapsuleHalfHeight) { return NativeCall<bool, TSubclassOf<APrimalCharacter>, float *, float *>(nullptr, "UVictoryCore.GetCharacterCapsuleSize", CharClass, OutCapsuleRadius, OutCapsuleHalfHeight); }
	static FString * GetClassPathName(FString * result, UObject * ForClass) { return NativeCall<FString *, FString *, UObject *>(nullptr, "UVictoryCore.GetClassPathName", result, ForClass); }
	static FString * GetClassString(FString * result, UClass * ForClass) { return NativeCall<FString *, FString *, UClass *>(nullptr, "UVictoryCore.GetClassString", result, ForClass); }
	static FVector2D * GetControllerMovementInputs(FVector2D * result, const APlayerController * ForPC) { return NativeCall<FVector2D *, FVector2D *, const APlayerController *>(nullptr, "UVictoryCore.GetControllerMovementInputs", result, ForPC); }
	static float GetCurrentCameraExposure() { return NativeCall<float>(nullptr, "UVictoryCore.GetCurrentCameraExposure"); }
	static FVector * GetCustomDinoSpawnLocation(FVector * result, UWorld * World, const FVector * SpawnLocation, const FRotator * SpawnRotation, const FDinoSetup * DinoSetup, float DebugDrawDuration, bool bApplyRotationToSpawnOffset) { return NativeCall<FVector *, FVector *, UWorld *, const FVector *, const FRotator *, const FDinoSetup *, float, bool>(nullptr, "UVictoryCore.GetCustomDinoSpawnLocation", result, World, SpawnLocation, SpawnRotation, DinoSetup, DebugDrawDuration, bApplyRotationToSpawnOffset); }
	static APrimalDinoCharacter * GetDinoCharacterByID(UObject * WorldContextObject, const int DinoID1, const int DinoID2, const bool bSearchTamedOnly) { return NativeCall<APrimalDinoCharacter *, UObject *, const int, const int, const bool>(nullptr, "UVictoryCore.GetDinoCharacterByID", WorldContextObject, DinoID1, DinoID2, bSearchTamedOnly); }
	static APrimalDinoCharacter * GetDinoCharacterByLongDinoID(UObject * WorldContextObject, const FString * DinoID, const bool bSearchTamedOnly) { return NativeCall<APrimalDinoCharacter *, UObject *, const FString *, const bool>(nullptr, "UVictoryCore.GetDinoCharacterByLongDinoID", WorldContextObject, DinoID, bSearchTamedOnly); }
	static bool GetDinoSetupCapsuleSize(const FDinoSetup * DinoSetup, float * CapsuleRadius, float * CapsuleHalfHeight) { return NativeCall<bool, const FDinoSetup *, float *, float *>(nullptr, "UVictoryCore.GetDinoSetupCapsuleSize", DinoSetup, CapsuleRadius, CapsuleHalfHeight); }
	static TSubclassOf<APrimalDinoCharacter> * GetDinoSetupDinoType(TSubclassOf<APrimalDinoCharacter> * result, const FDinoSetup * DinoSetup) { return NativeCall<TSubclassOf<APrimalDinoCharacter> *, TSubclassOf<APrimalDinoCharacter> *, const FDinoSetup *>(nullptr, "UVictoryCore.GetDinoSetupDinoType", result, DinoSetup); }
	static bool GetDinoSetupGroup_ByName(FName GroupName, const TArray<FDinoSetupGroup> * DinoSetupGroups, FDinoSetupGroup * OutGroup) { return NativeCall<bool, FName, const TArray<FDinoSetupGroup> *, FDinoSetupGroup *>(nullptr, "UVictoryCore.GetDinoSetupGroup_ByName", GroupName, DinoSetupGroups, OutGroup); }
	static bool GetDinoSetupGroup_WeightedRandom(const TArray<FDinoSetupGroup> * DinoSetupGroups, FDinoSetupGroup * OutGroup) { return NativeCall<bool, const TArray<FDinoSetupGroup> *, FDinoSetupGroup *>(nullptr, "UVictoryCore.GetDinoSetupGroup_WeightedRandom", DinoSetupGroups, OutGroup); }
	static int GetDinoSetupPointsPerStat(const FDinoSetup * DinoSetup, TEnumAsByte<enum EPrimalCharacterStatusValue::Type> StatusType, bool bGetPlayerAdded) { return NativeCall<int, const FDinoSetup *, TEnumAsByte<enum EPrimalCharacterStatusValue::Type>, bool>(nullptr, "UVictoryCore.GetDinoSetupPointsPerStat", DinoSetup, StatusType, bGetPlayerAdded); }
	static float GetDistanceToCollision(UPrimitiveComponent * comp, FVector point, FVector * closestPoint) { return NativeCall<float, UPrimitiveComponent *, FVector, FVector *>(nullptr, "UVictoryCore.GetDistanceToCollision", comp, point, closestPoint); }
	static ADirectionalLight * GetFirstDirectionalLight(UWorld * World) { return NativeCall<ADirectionalLight *, UWorld *>(nullptr, "UVictoryCore.GetFirstDirectionalLight", World); }
	static FVector * GetGPSCoords(FVector * result, UWorld * forWorld, const FVector * InLoc) { return NativeCall<FVector *, FVector *, UWorld *, const FVector *>(nullptr, "UVictoryCore.GetGPSCoords", result, forWorld, InLoc); }
	static bool GetGroundLocation(UWorld * forWorld, FVector * theGroundLoc, const FVector * StartLoc, const FVector * OffsetUp, const FVector * OffsetDown) { return NativeCall<bool, UWorld *, FVector *, const FVector *, const FVector *, const FVector *>(nullptr, "UVictoryCore.GetGroundLocation", forWorld, theGroundLoc, StartLoc, OffsetUp, OffsetDown); }
	static UPrimalHarvestingComponent * GetHarvestingComponentFromHitBodyIndex(UInstancedStaticMeshComponent * FromISMC, const int WithHitBodyIndex) { return NativeCall<UPrimalHarvestingComponent *, UInstancedStaticMeshComponent *, const int>(nullptr, "UVictoryCore.GetHarvestingComponentFromHitBodyIndex", FromISMC, WithHitBodyIndex); }
	static FName * GetHitBoneNameFromDamageEvent(FName * result, APrimalCharacter * Character, AController * HitInstigator, const FDamageEvent * DamageEvent, bool bIsPointDamage, const FHitResult * PointHitResult, FName MatchCollisionPresetName) { return NativeCall<FName *, FName *, APrimalCharacter *, AController *, const FDamageEvent *, bool, const FHitResult *, FName>(nullptr, "UVictoryCore.GetHitBoneNameFromDamageEvent", result, Character, HitInstigator, DamageEvent, bIsPointDamage, PointHitResult, MatchCollisionPresetName); }
	static FString * GetKeyName(FString * result, FKey key) { return NativeCall<FString *, FString *, FKey>(nullptr, "UVictoryCore.GetKeyName", result, key); }
	static FString * GetKeyNameFromActionName(FString * result, FName ActionName) { return NativeCall<FString *, FString *, FName>(nullptr, "UVictoryCore.GetKeyNameFromActionName", result, ActionName); }
	static FString * GetLastHostedMapPlayed(FString * result) { return NativeCall<FString *, FString *>(nullptr, "UVictoryCore.GetLastHostedMapPlayed", result); }
	static FString * GetLastMapPlayed(FString * result) { return NativeCall<FString *, FString *>(nullptr, "UVictoryCore.GetLastMapPlayed", result); }
	static void GetLaunchVelocityAndGravity(FVector StartLocation, FVector TargetLocation, float LateralSpeed, float PeakHeightZ, FVector * LaunchVelocity, float * Gravity) { NativeCall<void, FVector, FVector, float, float, FVector *, float *>(nullptr, "UVictoryCore.GetLaunchVelocityAndGravity", StartLocation, TargetLocation, LateralSpeed, PeakHeightZ, LaunchVelocity, Gravity); }
	static TArray<FName> * GetLoadedStreamingLevelNames(TArray<FName> * result) { return NativeCall<TArray<FName> *, TArray<FName> *>(nullptr, "UVictoryCore.GetLoadedStreamingLevelNames", result); }
	static bool GetLocaleSpecificAudio(const TArray<FLocalizedSoundCueEntry> * LocalizedSoundCues, FLocalizedSoundCueEntry * OutLocalizedAudio, const FString * LanguageOverride) { return NativeCall<bool, const TArray<FLocalizedSoundCueEntry> *, FLocalizedSoundCueEntry *, const FString *>(nullptr, "UVictoryCore.GetLocaleSpecificAudio", LocalizedSoundCues, OutLocalizedAudio, LanguageOverride); }
	static bool GetLocaleSpecificSoundWaveAnimTexturePairArrays(const TArray<FLocalizedSoundWaveAnimTexturePairArrays> * LocalizedSoundWaveAnimTextures, FLocalizedSoundWaveAnimTexturePairArrays * OutLocalizedAudio, bool * FoundLocalizedSoundWavesForThisLanguage, const FString * LanguageOverride) { return NativeCall<bool, const TArray<FLocalizedSoundWaveAnimTexturePairArrays> *, FLocalizedSoundWaveAnimTexturePairArrays *, bool *, const FString *>(nullptr, "UVictoryCore.GetLocaleSpecificSoundWaveAnimTexturePairArrays", LocalizedSoundWaveAnimTextures, OutLocalizedAudio, FoundLocalizedSoundWavesForThisLanguage, LanguageOverride); }
	static float GetMatineeLength(const AMatineeActor * MatineeActor) { return NativeCall<float, const AMatineeActor *>(nullptr, "UVictoryCore.GetMatineeLength", MatineeActor); }
	static long double GetMissionNetworkStartTime(UWorld * ForWorld, FName MissionTag) { return NativeCall<long double, UWorld *, FName>(nullptr, "UVictoryCore.GetMissionNetworkStartTime", ForWorld, MissionTag); }
	static long double GetNetworkTimeInSeconds(UObject * WorldContextObject) { return NativeCall<long double, UObject *>(nullptr, "UVictoryCore.GetNetworkTimeInSeconds", WorldContextObject); }
	static FString * GetNewlineCharacter(FString * result) { return NativeCall<FString *, FString *>(nullptr, "UVictoryCore.GetNewlineCharacter", result); }
	static FName * GetObjectName(FName * result, UObject * ForObject) { return NativeCall<FName *, FName *, UObject *>(nullptr, "UVictoryCore.GetObjectName", result, ForObject); }
	static FString * GetObjectPathName(FString * result, UObject * ForObject) { return NativeCall<FString *, FString *, UObject *>(nullptr, "UVictoryCore.GetObjectPathName", result, ForObject); }
	static FString * GetObjectString(FString * result, UObject * ForObject) { return NativeCall<FString *, FString *, UObject *>(nullptr, "UVictoryCore.GetObjectString", result, ForObject); }
	static void GetObjectsReferencedBy(UObject * ForObject, TArray<UObject *> * OutReferencedObjects, bool bIgnoreTransient) { NativeCall<void, UObject *, TArray<UObject *> *, bool>(nullptr, "UVictoryCore.GetObjectsReferencedBy", ForObject, OutReferencedObjects, bIgnoreTransient); }
	static bool GetOverlappedHarvestActors(UWorld * ForWorld, const FVector * AtLoc, float AtRadius, TArray<AActor *> * OutHarvestActors, TArray<UActorComponent *> * OutHarvestComponents, TArray<FVector> * OutHarvestLocations, TArray<int> * OutHitBodyIndices) { return NativeCall<bool, UWorld *, const FVector *, float, TArray<AActor *> *, TArray<UActorComponent *> *, TArray<FVector> *, TArray<int> *>(nullptr, "UVictoryCore.GetOverlappedHarvestActors", ForWorld, AtLoc, AtRadius, OutHarvestActors, OutHarvestComponents, OutHarvestLocations, OutHitBodyIndices); }
	static FVector * GetPlaneNormal(FVector * result, const FPlane * ForPlane) { return NativeCall<FVector *, FVector *, const FPlane *>(nullptr, "UVictoryCore.GetPlaneNormal", result, ForPlane); }
	static AShooterCharacter * GetPlayerCharacterByController(APlayerController * PC) { return NativeCall<AShooterCharacter *, APlayerController *>(nullptr, "UVictoryCore.GetPlayerCharacterByController", PC); }
	static AShooterCharacter * GetPlayerCharacterByIndex(UObject * WorldContextObject, int PlayerIndex) { return NativeCall<AShooterCharacter *, UObject *, int>(nullptr, "UVictoryCore.GetPlayerCharacterByIndex", WorldContextObject, PlayerIndex); }
	static UWorld * GetPrimaryWorld() { return NativeCall<UWorld *>(nullptr, "UVictoryCore.GetPrimaryWorld"); }
	static float GetProjectileArcPeakTime(UObject * WorldContextObject, const FProjectileArc * Arc) { return NativeCall<float, UObject *, const FProjectileArc *>(nullptr, "UVictoryCore.GetProjectileArcPeakTime", WorldContextObject, Arc); }
	static bool GetRandomWeightedDinoSetup(const TArray<FDinoSetup> * DinoSetupEntries, FDinoSetup * OutDinoSetup) { return NativeCall<bool, const TArray<FDinoSetup> *, FDinoSetup *>(nullptr, "UVictoryCore.GetRandomWeightedDinoSetup", DinoSetupEntries, OutDinoSetup); }
	static long double GetRealWorldUtcTimeInSeconds() { return NativeCall<long double>(nullptr, "UVictoryCore.GetRealWorldUtcTimeInSeconds"); }
	static float GetScreenFramePerfScalar() { return NativeCall<float>(nullptr, "UVictoryCore.GetScreenFramePerfScalar"); }
	static FVector2D * GetScreenPercentLocation(FVector2D * result, APlayerController * ForPC, const FVector2D ScreenPercentages) { return NativeCall<FVector2D *, FVector2D *, APlayerController *, const FVector2D>(nullptr, "UVictoryCore.GetScreenPercentLocation", result, ForPC, ScreenPercentages); }
	static float GetScreenPercentage() { return NativeCall<float>(nullptr, "UVictoryCore.GetScreenPercentage"); }
	static int GetSecondsIntoDay() { return NativeCall<int>(nullptr, "UVictoryCore.GetSecondsIntoDay"); }
	static AShooterCharacter * GetShooterCharacterFromController(AController * Controller) { return NativeCall<AShooterCharacter *, AController *>(nullptr, "UVictoryCore.GetShooterCharacterFromController", Controller); }
	static AShooterCharacter * GetShooterCharacterFromPawn(APawn * Pawn) { return NativeCall<AShooterCharacter *, APawn *>(nullptr, "UVictoryCore.GetShooterCharacterFromPawn", Pawn); }
	static UShooterGameUserSettings * GetShooterGameUserSettings() { return NativeCall<UShooterGameUserSettings *>(nullptr, "UVictoryCore.GetShooterGameUserSettings"); }
	static float GetSimpleMontageDuration(UAnimMontage * GivenMontage, float GivenPlayRate) { return NativeCall<float, UAnimMontage *, float>(nullptr, "UVictoryCore.GetSimpleMontageDuration", GivenMontage, GivenPlayRate); }
	static FString * GetSoundCueLocalizedSpokenText(FString * result, USoundCue * inSound) { return NativeCall<FString *, FString *, USoundCue *>(nullptr, "UVictoryCore.GetSoundCueLocalizedSpokenText", result, inSound); }
	static FString * GetSoundWaveLocalizedSpokenText(FString * result, USoundWave * inSound) { return NativeCall<FString *, FString *, USoundWave *>(nullptr, "UVictoryCore.GetSoundWaveLocalizedSpokenText", result, inSound); }
	static void GetSpecialActorList(UWorld * ForWorld, TEnumAsByte<enum EActorListsBP::Type> ActorListType, TArray<AActor *> * OutActors) { NativeCall<void, UWorld *, TEnumAsByte<enum EActorListsBP::Type>, TArray<AActor *> *>(nullptr, "UVictoryCore.GetSpecialActorList", ForWorld, ActorListType, OutActors); }
	static FBoxSphereBounds * GetStaticMeshBounds(FBoxSphereBounds * result, const UStaticMesh * ForMesh) { return NativeCall<FBoxSphereBounds *, FBoxSphereBounds *, const UStaticMesh *>(nullptr, "UVictoryCore.GetStaticMeshBounds", result, ForMesh); }
	static FColor * GetTeamColor(FColor * result, const int TargetingTeam) { return NativeCall<FColor *, FColor *, const int>(nullptr, "UVictoryCore.GetTeamColor", result, TargetingTeam); }
	static float GetTimeSeconds(APawn * pawn) { return NativeCall<float, APawn *>(nullptr, "UVictoryCore.GetTimeSeconds", pawn); }
	static float GetTimeSince(APawn * pawn, float time) { return NativeCall<float, APawn *, float>(nullptr, "UVictoryCore.GetTimeSince", pawn, time); }
	static FString * GetTotalCoversionIdAsString(FString * result) { return NativeCall<FString *, FString *>(nullptr, "UVictoryCore.GetTotalCoversionIdAsString", result); }
	static FString * GetTwoLetterISOLanguageName(FString * result) { return NativeCall<FString *, FString *>(nullptr, "UVictoryCore.GetTwoLetterISOLanguageName", result); }
	static FVector * GetVelocityDeltaBetweenChars(FVector * result, APrimalCharacter * CharA, APrimalCharacter * CharB) { return NativeCall<FVector *, FVector *, APrimalCharacter *, APrimalCharacter *>(nullptr, "UVictoryCore.GetVelocityDeltaBetweenChars", result, CharA, CharB); }
	static float GetVolumeOfCapsule(const float CapsuleRadius, const float CapsuleHalfHeight) { return NativeCall<float, const float, const float>(nullptr, "UVictoryCore.GetVolumeOfCapsule", CapsuleRadius, CapsuleHalfHeight); }
	static int GetWeightedRandomIndexFromArray(TArray<float> pArray, float ForceRand) { return NativeCall<int, TArray<float>, float>(nullptr, "UVictoryCore.GetWeightedRandomIndexFromArray", pArray, ForceRand); }
	static long double GetWorldLoadedAtTime(UObject * WorldContextObject) { return NativeCall<long double, UObject *>(nullptr, "UVictoryCore.GetWorldLoadedAtTime", WorldContextObject); }
	static void GridTraceAroundPoint(UObject * WorldContextObject, TArray<FHitResult> * OutResults, FVector Origin, FRotator GridRotation, TArray<AActor *> ActorsToIgnore, ECollisionChannel CollisionChannel, int NumTracesX, int NumTracesY, float SpacingX, float SpacingY, float ZStartOffset, float ZEndOffset, bool bTraceComplex, bool bDrawDebug, float DebugDrawDuration) { NativeCall<void, UObject *, TArray<FHitResult> *, FVector, FRotator, TArray<AActor *>, ECollisionChannel, int, int, float, float, float, float, bool, bool, float>(nullptr, "UVictoryCore.GridTraceAroundPoint", WorldContextObject, OutResults, Origin, GridRotation, ActorsToIgnore, CollisionChannel, NumTracesX, NumTracesY, SpacingX, SpacingY, ZStartOffset, ZEndOffset, bTraceComplex, bDrawDebug, DebugDrawDuration); }
	static void GrindAllItemsToInventory(UPrimalInventoryComponent * inventory, const bool bGrindStack, const int MaxQuantityToGrind, const float GrindGiveItemsPercent, const int MaxItemsToGivePerGrind) { NativeCall<void, UPrimalInventoryComponent *, const bool, const int, const float, const int>(nullptr, "UVictoryCore.GrindAllItemsToInventory", inventory, bGrindStack, MaxQuantityToGrind, GrindGiveItemsPercent, MaxItemsToGivePerGrind); }
	static bool GrindItemIntoInventory(UPrimalItem * item, UPrimalInventoryComponent * inventory, const bool bGrindStack, const int MaxQuantityToGrind, const float GrindGiveItemsPercent, const int MaxItemsToGivePerGrind) { return NativeCall<bool, UPrimalItem *, UPrimalInventoryComponent *, const bool, const int, const float, const int>(nullptr, "UVictoryCore.GrindItemIntoInventory", item, inventory, bGrindStack, MaxQuantityToGrind, GrindGiveItemsPercent, MaxItemsToGivePerGrind); }
	static bool HasCraftingRequirementsGreaterThanOne(const UPrimalItem * item) { return NativeCall<bool, const UPrimalItem *>(nullptr, "UVictoryCore.HasCraftingRequirementsGreaterThanOne", item); }
	static bool HasPlayerSeenGen2Intro(UObject * WorldContextObject) { return NativeCall<bool, UObject *>(nullptr, "UVictoryCore.HasPlayerSeenGen2Intro", WorldContextObject); }
	static FVector * Helix(FVector * result, float Radius, float Time) { return NativeCall<FVector *, FVector *, float, float>(nullptr, "UVictoryCore.Helix", result, Radius, Time); }
	static void InlineLoadLevels(const TArray<FName> * LevelNames, const TArray<FName> * LevelNamesToUnload, bool bDisableDistanceStreamingOnLevels) { NativeCall<void, const TArray<FName> *, const TArray<FName> *, bool>(nullptr, "UVictoryCore.InlineLoadLevels", LevelNames, LevelNamesToUnload, bDisableDistanceStreamingOnLevels); }
	static FString * IntToStringAscii(FString * result, int CharValue) { return NativeCall<FString *, FString *, int>(nullptr, "UVictoryCore.IntToStringAscii", result, CharValue); }
	static bool IntersectsBox(const FVector * Origin, const FVector * Extents, const UShapeComponent * shapeComponent) { return NativeCall<bool, const FVector *, const FVector *, const UShapeComponent *>(nullptr, "UVictoryCore.IntersectsBox", Origin, Extents, shapeComponent); }
	static FTransform * InverseTransform(FTransform * result, const FTransform * TransformIn) { return NativeCall<FTransform *, FTransform *, const FTransform *>(nullptr, "UVictoryCore.InverseTransform", result, TransformIn); }
	static FVector2D * InverseTransformVectorByScreenProjectionGlobalTransform(FVector2D * result, const FVector2D vec) { return NativeCall<FVector2D *, FVector2D *, const FVector2D>(nullptr, "UVictoryCore.InverseTransformVectorByScreenProjectionGlobalTransform", result, vec); }
	static bool IsBrainControllingDinoAttached(APrimalCharacter * character) { return NativeCall<bool, APrimalCharacter *>(nullptr, "UVictoryCore.IsBrainControllingDinoAttached", character); }
	static int IsChildOfClasses(TSubclassOf<UObject> childClass, const TArray<TSubclassOf<UObject>> * ParentClassesArray) { return NativeCall<int, TSubclassOf<UObject>, const TArray<TSubclassOf<UObject>> *>(nullptr, "UVictoryCore.IsChildOfClasses", childClass, ParentClassesArray); }
	static int IsChildOfClassesSoft(TSubclassOf<UObject> childClass, const TArray<FString> * ParentClassesArraySoft) { return NativeCall<int, TSubclassOf<UObject>, const TArray<FString> *>(nullptr, "UVictoryCore.IsChildOfClassesSoft", childClass, ParentClassesArraySoft); }
	static bool IsConsoleBuild() { return NativeCall<bool>(nullptr, "UVictoryCore.IsConsoleBuild"); }
	static bool IsConsoleServerBuild() { return NativeCall<bool>(nullptr, "UVictoryCore.IsConsoleServerBuild"); }
	static bool IsCooldownComplete(UObject * WorldContextObject, long double CooldownClock, float NumSeconds) { return NativeCall<bool, UObject *, long double, float>(nullptr, "UVictoryCore.IsCooldownComplete", WorldContextObject, CooldownClock, NumSeconds); }
	static bool IsCryopodNerfEnabled(UObject * WorldContextObject, float * damageMult, float * duration, float * incomingDamageMultPercent) { return NativeCall<bool, UObject *, float *, float *, float *>(nullptr, "UVictoryCore.IsCryopodNerfEnabled", WorldContextObject, damageMult, duration, incomingDamageMultPercent); }
	static bool IsDinoDuped(UWorld * WorldContext, const unsigned int id1, const unsigned int id2) { return NativeCall<bool, UWorld *, const unsigned int, const unsigned int>(nullptr, "UVictoryCore.IsDinoDuped", WorldContext, id1, id2); }
	static bool IsDistanceGreaterThan(FVector A, FVector B, float Distance) { return NativeCall<bool, FVector, FVector, float>(nullptr, "UVictoryCore.IsDistanceGreaterThan", A, B, Distance); }
	static bool IsDistanceLessThan(FVector A, FVector B, float Distance) { return NativeCall<bool, FVector, FVector, float>(nullptr, "UVictoryCore.IsDistanceLessThan", A, B, Distance); }
	static bool IsEpicClient() { return NativeCall<bool>(nullptr, "UVictoryCore.IsEpicClient"); }
	static bool IsGamePadConnected() { return NativeCall<bool>(nullptr, "UVictoryCore.IsGamePadConnected"); }
	static bool IsGameWorld(UWorld * theWorld) { return NativeCall<bool, UWorld *>(nullptr, "UVictoryCore.IsGameWorld", theWorld); }
	static bool IsInsideBox(const FVector * Origin, const FVector * Extents, const UShapeComponent * shapeComponent) { return NativeCall<bool, const FVector *, const FVector *, const UShapeComponent *>(nullptr, "UVictoryCore.IsInsideBox", Origin, Extents, shapeComponent); }
	static bool IsInsideOrIntersectsBox(const FVector * Origin, const FVector * Extents, const UShapeComponent * shapeComponent) { return NativeCall<bool, const FVector *, const FVector *, const UShapeComponent *>(nullptr, "UVictoryCore.IsInsideOrIntersectsBox", Origin, Extents, shapeComponent); }
	static bool IsLoadingSaveGame() { return NativeCall<bool>(nullptr, "UVictoryCore.IsLoadingSaveGame"); }
	static bool IsMissionActiveAnywhere(TSubclassOf<AMissionType> MissionType) { return NativeCall<bool, TSubclassOf<AMissionType>>(nullptr, "UVictoryCore.IsMissionActiveAnywhere", MissionType); }
	static bool IsMissionTagActiveAnywhere(AShooterPlayerController * FromPC, FName MissionTag) { return NativeCall<bool, AShooterPlayerController *, FName>(nullptr, "UVictoryCore.IsMissionTagActiveAnywhere", FromPC, MissionTag); }
	static bool IsNonHostPlayer(UWorld * theWorld, AController * playerController) { return NativeCall<bool, UWorld *, AController *>(nullptr, "UVictoryCore.IsNonHostPlayer", theWorld, playerController); }
	static bool IsOfficialServer() { return NativeCall<bool>(nullptr, "UVictoryCore.IsOfficialServer"); }
	static bool IsPS4Build() { return NativeCall<bool>(nullptr, "UVictoryCore.IsPS4Build"); }
	static bool IsPVEServer(UObject * WorldContextObject) { return NativeCall<bool, UObject *>(nullptr, "UVictoryCore.IsPVEServer", WorldContextObject); }
	static bool IsPointInCone(const FVector * Point, const FVector * ConeOrigin, const FVector * ConeDir, float ConeLength, float ConeHalfAngle) { return NativeCall<bool, const FVector *, const FVector *, const FVector *, float, float>(nullptr, "UVictoryCore.IsPointInCone", Point, ConeOrigin, ConeDir, ConeLength, ConeHalfAngle); }
	static bool IsPointStuckWithinMesh(UWorld * theWorld, FVector TestPoint, int hemisphereSubdivisions, float rayDistance, float percentageConsideredStuck, AActor * ActorToIgnore) { return NativeCall<bool, UWorld *, FVector, int, float, float, AActor *>(nullptr, "UVictoryCore.IsPointStuckWithinMesh", theWorld, TestPoint, hemisphereSubdivisions, rayDistance, percentageConsideredStuck, ActorToIgnore); }
	static bool IsSavingSaveGame() { return NativeCall<bool>(nullptr, "UVictoryCore.IsSavingSaveGame"); }
	static bool IsSplitscreen() { return NativeCall<bool>(nullptr, "UVictoryCore.IsSplitscreen"); }
	static bool IsTimeSince(UWorld * ForWorld, long double OldTime, float CheckTimeSince, bool bForceTrueAtZeroTime) { return NativeCall<bool, UWorld *, long double, float, bool>(nullptr, "UVictoryCore.IsTimeSince", ForWorld, OldTime, CheckTimeSince, bForceTrueAtZeroTime); }
	static bool IsTimeSince_Network(UWorld * ForWorld, long double OldTime, float CheckTimeSince, bool bForceTrueAtZeroTime) { return NativeCall<bool, UWorld *, long double, float, bool>(nullptr, "UVictoryCore.IsTimeSince_Network", ForWorld, OldTime, CheckTimeSince, bForceTrueAtZeroTime); }
	static bool IsTimeSince_Utc(long double OldTime, float CheckTimeSince, bool bForceTrueAtZeroTime) { return NativeCall<bool, long double, float, bool>(nullptr, "UVictoryCore.IsTimeSince_Utc", OldTime, CheckTimeSince, bForceTrueAtZeroTime); }
	static bool IsTimerActive(UObject * Object, FString FunctionName) { return NativeCall<bool, UObject *, FString>(nullptr, "UVictoryCore.IsTimerActive", Object, FunctionName); }
	static bool IsTimerPaused(UObject * Object, FString FunctionName) { return NativeCall<bool, UObject *, FString>(nullptr, "UVictoryCore.IsTimerPaused", Object, FunctionName); }
	static bool IsUnderMesh(APrimalCharacter * Character, FVector * CheckSevenHitLocation, bool * bOverlapping, UActorComponent ** CheckSevenResult, bool DebugDraw, float DebugDrawSeconds) { return NativeCall<bool, APrimalCharacter *, FVector *, bool *, UActorComponent **, bool, float>(nullptr, "UVictoryCore.IsUnderMesh", Character, CheckSevenHitLocation, bOverlapping, CheckSevenResult, DebugDraw, DebugDrawSeconds); }
	static bool IsValidItemForGrinding(const UPrimalItem * item, const UPrimalInventoryComponent * inventory) { return NativeCall<bool, const UPrimalItem *, const UPrimalInventoryComponent *>(nullptr, "UVictoryCore.IsValidItemForGrinding", item, inventory); }
	static bool IsWorkshopIDSubscribed(const FString * WorkshopID) { return NativeCall<bool, const FString *>(nullptr, "UVictoryCore.IsWorkshopIDSubscribed", WorkshopID); }
	static bool IsXboxOneBuild() { return NativeCall<bool>(nullptr, "UVictoryCore.IsXboxOneBuild"); }
	static FString * JoinStringArrayWithNewlines(FString * result, const TArray<FString> * SourceArray) { return NativeCall<FString *, FString *, const TArray<FString> *>(nullptr, "UVictoryCore.JoinStringArrayWithNewlines", result, SourceArray); }
	static bool KillTargetCharacterOrStructure(AActor * ActorToKill, AActor * DamageCauser, bool bTryDestroyActor) { return NativeCall<bool, AActor *, AActor *, bool>(nullptr, "UVictoryCore.KillTargetCharacterOrStructure", ActorToKill, DamageCauser, bTryDestroyActor); }
	static FVector * LeadTargetPosition(FVector * result, const FVector * ProjLocation, float ProjSpeed, const FVector * TargetLocation, const FVector * TargetVelocity) { return NativeCall<FVector *, FVector *, const FVector *, float, const FVector *, const FVector *>(nullptr, "UVictoryCore.LeadTargetPosition", result, ProjLocation, ProjSpeed, TargetLocation, TargetVelocity); }
	static FString * LeaderboardColumnNameToString(FString * result, TEnumAsByte<enum ELeaderboardColumnName::Type> ColumnType) { return NativeCall<FString *, FString *, TEnumAsByte<enum ELeaderboardColumnName::Type>>(nullptr, "UVictoryCore.LeaderboardColumnNameToString", result, ColumnType); }
	static FString * ListDinos(FString * result, UObject * WorldContextObject, const bool TamedOnly, const int TargetingTeamExcluded) { return NativeCall<FString *, FString *, UObject *, const bool, const int>(nullptr, "UVictoryCore.ListDinos", result, WorldContextObject, TamedOnly, TargetingTeamExcluded); }
	static FHitResult * MakeHitResult(FHitResult * result, FVector Location, FVector Normal, UPhysicalMaterial * PhysMat, AActor * HitActor, UPrimitiveComponent * HitComponent, FName HitBoneName, int HitItem, bool bBlockingHit) { return NativeCall<FHitResult *, FHitResult *, FVector, FVector, UPhysicalMaterial *, AActor *, UPrimitiveComponent *, FName, int, bool>(nullptr, "UVictoryCore.MakeHitResult", result, Location, Normal, PhysMat, HitActor, HitComponent, HitBoneName, HitItem, bBlockingHit); }
	static float MapAngleRangeToCurveClamped(float AngleDegrees, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB, TEnumAsByte<enum ESimpleCurve::Type> CurveType) { return NativeCall<float, float, float, float, float, float, TEnumAsByte<enum ESimpleCurve::Type>>(nullptr, "UVictoryCore.MapAngleRangeToCurveClamped", AngleDegrees, InRangeA, InRangeB, OutRangeA, OutRangeB, CurveType); }
	static float MapRangeToCurveClamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB, TEnumAsByte<enum ESimpleCurve::Type> CurveType) { return NativeCall<float, float, float, float, float, float, TEnumAsByte<enum ESimpleCurve::Type>>(nullptr, "UVictoryCore.MapRangeToCurveClamped", Value, InRangeA, InRangeB, OutRangeA, OutRangeB, CurveType); }
	static void MarkGen2IntroAsSeen(UObject * WorldContextObject) { NativeCall<void, UObject *>(nullptr, "UVictoryCore.MarkGen2IntroAsSeen", WorldContextObject); }
	static FDinoSetup * ModifyDinoSetupTargetLevel(FDinoSetup * result, const FDinoSetup * DinoSetup, float LevelMultiplier, int MinLevel, int MaxLevel) { return NativeCall<FDinoSetup *, FDinoSetup *, const FDinoSetup *, float, int, int>(nullptr, "UVictoryCore.ModifyDinoSetupTargetLevel", result, DinoSetup, LevelMultiplier, MinLevel, MaxLevel); }
	static void MultiLinePenetrationTraceByChannel(UObject * WorldContextObject, TArray<FPenetrationTraceHit> * OutResults, const FVector * Start, const FVector * End, ECollisionChannel TraceChannel, const TArray<AActor *> * ActorsToIgnore, bool bTraceComplex, bool bIgnoreSelf, bool bDrawDebugLines, float DebugDrawDuration) { NativeCall<void, UObject *, TArray<FPenetrationTraceHit> *, const FVector *, const FVector *, ECollisionChannel, const TArray<AActor *> *, bool, bool, bool, float>(nullptr, "UVictoryCore.MultiLinePenetrationTraceByChannel", WorldContextObject, OutResults, Start, End, TraceChannel, ActorsToIgnore, bTraceComplex, bIgnoreSelf, bDrawDebugLines, DebugDrawDuration); }
	static void MultiTraceProjectSphere(UObject * WorldContextObject, TArray<FHitResult> * OutResults, const FVector * Origin, ECollisionChannel TraceChannel, int HorizResolution, int VertResolution, float StartDistance, float EndDistance, float NorthConeSubtractAngle, float SouthConeSubtractAngle, int PctChanceToTrace, int MaxTraceCount, bool bDrawDebugLines, float DebugDrawDuration, bool bStopOnFirstHit) { NativeCall<void, UObject *, TArray<FHitResult> *, const FVector *, ECollisionChannel, int, int, float, float, float, float, int, int, bool, float, bool>(nullptr, "UVictoryCore.MultiTraceProjectSphere", WorldContextObject, OutResults, Origin, TraceChannel, HorizResolution, VertResolution, StartDistance, EndDistance, NorthConeSubtractAngle, SouthConeSubtractAngle, PctChanceToTrace, MaxTraceCount, bDrawDebugLines, DebugDrawDuration, bStopOnFirstHit); }
	static void MulticastDrawDebugArrow(AActor * ReplicatedActor, const FVector LineStart, const FVector LineEnd, float ArrowSize, FLinearColor LineColor, float Duration) { NativeCall<void, AActor *, const FVector, const FVector, float, FLinearColor, float>(nullptr, "UVictoryCore.MulticastDrawDebugArrow", ReplicatedActor, LineStart, LineEnd, ArrowSize, LineColor, Duration); }
	static void MulticastDrawDebugBox(AActor * ReplicatedActor, const FVector Center, FVector Extent, FLinearColor LineColor, const FRotator Rotation, float Duration) { NativeCall<void, AActor *, const FVector, FVector, FLinearColor, const FRotator, float>(nullptr, "UVictoryCore.MulticastDrawDebugBox", ReplicatedActor, Center, Extent, LineColor, Rotation, Duration); }
	static void MulticastDrawDebugCamera(AActor * ReplicatedActor, const ACameraActor * CameraActor, FLinearColor CameraColor, float Duration) { NativeCall<void, AActor *, const ACameraActor *, FLinearColor, float>(nullptr, "UVictoryCore.MulticastDrawDebugCamera", ReplicatedActor, CameraActor, CameraColor, Duration); }
	static void MulticastDrawDebugCapsule(AActor * ReplicatedActor, const FVector Center, float HalfHeight, float Radius, const FRotator Rotation, FLinearColor LineColor, float Duration) { NativeCall<void, AActor *, const FVector, float, float, const FRotator, FLinearColor, float>(nullptr, "UVictoryCore.MulticastDrawDebugCapsule", ReplicatedActor, Center, HalfHeight, Radius, Rotation, LineColor, Duration); }
	static void MulticastDrawDebugCapsuleWithExtents(AActor * ReplicatedActor, const FVector Top, const FVector Bottom, float Radius, FLinearColor LineColor, float Duration, bool bPersistent) { NativeCall<void, AActor *, const FVector, const FVector, float, FLinearColor, float, bool>(nullptr, "UVictoryCore.MulticastDrawDebugCapsuleWithExtents", ReplicatedActor, Top, Bottom, Radius, LineColor, Duration, bPersistent); }
	static void MulticastDrawDebugCoordinateSystem(AActor * ReplicatedActor, const FVector AxisLoc, const FRotator AxisRot, float Scale, float Duration, float Thickness) { NativeCall<void, AActor *, const FVector, const FRotator, float, float, float>(nullptr, "UVictoryCore.MulticastDrawDebugCoordinateSystem", ReplicatedActor, AxisLoc, AxisRot, Scale, Duration, Thickness); }
	static void MulticastDrawDebugCylinder(AActor * ReplicatedActor, const FVector Start, const FVector End, float Radius, int Segments, FLinearColor LineColor, float Duration) { NativeCall<void, AActor *, const FVector, const FVector, float, int, FLinearColor, float>(nullptr, "UVictoryCore.MulticastDrawDebugCylinder", ReplicatedActor, Start, End, Radius, Segments, LineColor, Duration); }
	static void MulticastDrawDebugLine(AActor * ReplicatedActor, const FVector LineStart, const FVector LineEnd, FLinearColor LineColor, float Duration, float Thickness, const bool allowInShipping) { NativeCall<void, AActor *, const FVector, const FVector, FLinearColor, float, float, const bool>(nullptr, "UVictoryCore.MulticastDrawDebugLine", ReplicatedActor, LineStart, LineEnd, LineColor, Duration, Thickness, allowInShipping); }
	static void MulticastDrawDebugPoint(AActor * ReplicatedActor, const FVector Position, float Size, FLinearColor PointColor, float Duration) { NativeCall<void, AActor *, const FVector, float, FLinearColor, float>(nullptr, "UVictoryCore.MulticastDrawDebugPoint", ReplicatedActor, Position, Size, PointColor, Duration); }
	static void MulticastDrawDebugSphere(AActor * ReplicatedActor, const FVector Center, float Radius, int Segments, FLinearColor LineColor, float Duration) { NativeCall<void, AActor *, const FVector, float, int, FLinearColor, float>(nullptr, "UVictoryCore.MulticastDrawDebugSphere", ReplicatedActor, Center, Radius, Segments, LineColor, Duration); }
	static void MulticastDrawDebugString(AActor * ReplicatedActor, const FVector TextLocation, const FString * Text, AActor * TestBaseActor, FLinearColor TextColor, float Duration) { NativeCall<void, AActor *, const FVector, const FString *, AActor *, FLinearColor, float>(nullptr, "UVictoryCore.MulticastDrawDebugString", ReplicatedActor, TextLocation, Text, TestBaseActor, TextColor, Duration); }
	static long double NetworkTimeToRealWorldUtcTime(UObject * WorldContextObject, long double NetworkTime) { return NativeCall<long double, UObject *, long double>(nullptr, "UVictoryCore.NetworkTimeToRealWorldUtcTime", WorldContextObject, NetworkTime); }
	static FRotator * NormalizeRotator(FRotator * result, FRotator InRotator) { return NativeCall<FRotator *, FRotator *, FRotator>(nullptr, "UVictoryCore.NormalizeRotator", result, InRotator); }
	static bool ObjectIsChildOf(UObject * Object, UClass * ObjectType, bool bExactMatch) { return NativeCall<bool, UObject *, UClass *, bool>(nullptr, "UVictoryCore.ObjectIsChildOf", Object, ObjectType, bExactMatch); }
	static void OpenStorePageForDLC(FString DLCName) { NativeCall<void, FString>(nullptr, "UVictoryCore.OpenStorePageForDLC", DLCName); }
	static bool OverlappingActorsBP(UWorld * theWorld, TArray<FOverlapResult> * Overlaps, FVector Origin, float Radius, int CollisionGroups, AActor * InIgnoreActor, FName TraceName, bool bComplexOverlapTest) { return NativeCall<bool, UWorld *, TArray<FOverlapResult> *, FVector, float, int, AActor *, FName, bool>(nullptr, "UVictoryCore.OverlappingActorsBP", theWorld, Overlaps, Origin, Radius, CollisionGroups, InIgnoreActor, TraceName, bComplexOverlapTest); }
	static bool OverlappingActorsTraceBP(UWorld * theWorld, TArray<FOverlapResult> * Overlaps, FVector Origin, float Radius, ECollisionChannel TraceChannel, AActor * InIgnoreActor, FName TraceName, bool bComplexOverlapTest) { return NativeCall<bool, UWorld *, TArray<FOverlapResult> *, FVector, float, ECollisionChannel, AActor *, FName, bool>(nullptr, "UVictoryCore.OverlappingActorsTraceBP", theWorld, Overlaps, Origin, Radius, TraceChannel, InIgnoreActor, TraceName, bComplexOverlapTest); }
	static bool OverlappingStationaryObjectsTrace(UWorld * theWorld, APrimalCharacter * SourceCharacter, TArray<FOverlapResult> * Overlaps, FVector Origin, float Radius, ECollisionChannel TraceChannel, AActor * InIgnoreActor, FName TraceName, bool bComplexOverlapTest) { return NativeCall<bool, UWorld *, APrimalCharacter *, TArray<FOverlapResult> *, FVector, float, ECollisionChannel, AActor *, FName, bool>(nullptr, "UVictoryCore.OverlappingStationaryObjectsTrace", theWorld, SourceCharacter, Overlaps, Origin, Radius, TraceChannel, InIgnoreActor, TraceName, bComplexOverlapTest); }
	static bool OverlappingStationaryObjectsTraceBP(UWorld * theWorld, APrimalCharacter * SourceCharacter, TArray<FOverlapResult> * Overlaps, FVector Origin, float Radius, ECollisionChannel TraceChannel, AActor * InIgnoreActor, FName TraceName, bool bComplexOverlapTest) { return NativeCall<bool, UWorld *, APrimalCharacter *, TArray<FOverlapResult> *, FVector, float, ECollisionChannel, AActor *, FName, bool>(nullptr, "UVictoryCore.OverlappingStationaryObjectsTraceBP", theWorld, SourceCharacter, Overlaps, Origin, Radius, TraceChannel, InIgnoreActor, TraceName, bComplexOverlapTest); }
	static bool OwnsAberration() { return NativeCall<bool>(nullptr, "UVictoryCore.OwnsAberration"); }
	static bool OwnsCrystalIsles() { return NativeCall<bool>(nullptr, "UVictoryCore.OwnsCrystalIsles"); }
	static bool OwnsDLC(FString DLCName) { return NativeCall<bool, FString>(nullptr, "UVictoryCore.OwnsDLC", DLCName); }
	static bool OwnsExtinction() { return NativeCall<bool>(nullptr, "UVictoryCore.OwnsExtinction"); }
	static bool OwnsGenesis() { return NativeCall<bool>(nullptr, "UVictoryCore.OwnsGenesis"); }
	static bool OwnsGenesisSeasonPass() { return NativeCall<bool>(nullptr, "UVictoryCore.OwnsGenesisSeasonPass"); }
	static bool OwnsScorchedEarth() { return NativeCall<bool>(nullptr, "UVictoryCore.OwnsScorchedEarth"); }
	static bool OwnsSteamAppID(int AppID) { return NativeCall<bool, int>(nullptr, "UVictoryCore.OwnsSteamAppID", AppID); }
	static void PauseTimer(UObject * Object, FString FunctionName) { NativeCall<void, UObject *, FString>(nullptr, "UVictoryCore.PauseTimer", Object, FunctionName); }
	static void PlaceStructure(AShooterCharacter * placingPawn, TSubclassOf<APrimalStructure> StructureToPlace, FItemNetID itemID, bool DisplayFailMessage) { NativeCall<void, AShooterCharacter *, TSubclassOf<APrimalStructure>, FItemNetID, bool>(nullptr, "UVictoryCore.PlaceStructure", placingPawn, StructureToPlace, itemID, DisplayFailMessage); }
	static void PlayCompanionReactionOnSolePlayer(APrimalCharacter * PlayerWhoGetReaction, FCompanionReactionData * ReactionData, const bool ForcePlayNow, UMaterialInterface * OverrideDialogueIcon, const bool RestrictedEnvironmentalReaction, const int UniqueID) { NativeCall<void, APrimalCharacter *, FCompanionReactionData *, const bool, UMaterialInterface *, const bool, const int>(nullptr, "UVictoryCore.PlayCompanionReactionOnSolePlayer", PlayerWhoGetReaction, ReactionData, ForcePlayNow, OverrideDialogueIcon, RestrictedEnvironmentalReaction, UniqueID); }
	static void PlayCompanionReactionToPlayers(TArray<APrimalCharacter *> PlayersWhoGetReaction, FCompanionReactionData * ReactionData, const bool ForcePlayNow, UMaterialInterface * OverrideDialogueIcon, const bool RestrictedEnvironmentalReaction, const int UniqueID) { NativeCall<void, TArray<APrimalCharacter *>, FCompanionReactionData *, const bool, UMaterialInterface *, const bool, const int>(nullptr, "UVictoryCore.PlayCompanionReactionToPlayers", PlayersWhoGetReaction, ReactionData, ForcePlayNow, OverrideDialogueIcon, RestrictedEnvironmentalReaction, UniqueID); }
	static void PlayMusic(FString MusicFile, float OverrideVolume) { NativeCall<void, FString, float>(nullptr, "UVictoryCore.PlayMusic", MusicFile, OverrideVolume); }
	static bool PlayerOwnsAberrationServer(AShooterPlayerController * controller) { return NativeCall<bool, AShooterPlayerController *>(nullptr, "UVictoryCore.PlayerOwnsAberrationServer", controller); }
	static bool PlayerOwnsExtinctionServer(AShooterPlayerController * controller) { return NativeCall<bool, AShooterPlayerController *>(nullptr, "UVictoryCore.PlayerOwnsExtinctionServer", controller); }
	static bool PlayerOwnsGenesisSeasonPassServer(AShooterPlayerController * controller) { return NativeCall<bool, AShooterPlayerController *>(nullptr, "UVictoryCore.PlayerOwnsGenesisSeasonPassServer", controller); }
	static bool PlayerOwnsScorchedEarthServer(AShooterPlayerController * controller) { return NativeCall<bool, AShooterPlayerController *>(nullptr, "UVictoryCore.PlayerOwnsScorchedEarthServer", controller); }
	static FVector2D * PointOnCircle(FVector2D * result, float Radius, float AngleDegrees) { return NativeCall<FVector2D *, FVector2D *, float, float>(nullptr, "UVictoryCore.PointOnCircle", result, Radius, AngleDegrees); }
	static FVector * PointOnSphere(FVector * result, float Radius, float DegreesI, float DegreesJ) { return NativeCall<FVector *, FVector *, float, float, float>(nullptr, "UVictoryCore.PointOnSphere", result, Radius, DegreesI, DegreesJ); }
	static TArray<FVector> * PointsOnACircle(TArray<FVector> * result, const FVector * Center, float Radius, int NumPoints) { return NativeCall<TArray<FVector> *, TArray<FVector> *, const FVector *, float, int>(nullptr, "UVictoryCore.PointsOnACircle", result, Center, Radius, NumPoints); }
	static TArray<FVector> * PointsOnAGrid(TArray<FVector> * result, UObject * WorldContextObject, const FVector * Center, const FRotator * Rotation, float Radius, float MinSize, int NumPoints, float DebugDrawDuration) { return NativeCall<TArray<FVector> *, TArray<FVector> *, UObject *, const FVector *, const FRotator *, float, float, int, float>(nullptr, "UVictoryCore.PointsOnAGrid", result, WorldContextObject, Center, Rotation, Radius, MinSize, NumPoints, DebugDrawDuration); }
	static TArray<FVector> * PointsRandomDist(TArray<FVector> * result, const FVector * Location, int NumPoints, float Radius, float PointRadius) { return NativeCall<TArray<FVector> *, TArray<FVector> *, const FVector *, int, float, float>(nullptr, "UVictoryCore.PointsRandomDist", result, Location, NumPoints, Radius, PointRadius); }
	static float PrecisionRound(float inputVal, int Precision) { return NativeCall<float, float, int>(nullptr, "UVictoryCore.PrecisionRound", inputVal, Precision); }
	static void PrintMessageInShippingBuild(const FString * msg) { NativeCall<void, const FString *>(nullptr, "UVictoryCore.PrintMessageInShippingBuild", msg); }
	static FVector * ProjectLocationToEdgeOfSphere(FVector * result, bool * bOutDidProject, const FVector * ForLocation, const FVector * SphereOrigin, const float * SphereRadius, const bool bOnlyProjectIfWithinRadius, const bool bForceProjection2D, const bool bDebug, AActor * DebugContextActor, const float DebugDuration) { return NativeCall<FVector *, FVector *, bool *, const FVector *, const FVector *, const float *, const bool, const bool, const bool, AActor *, const float>(nullptr, "UVictoryCore.ProjectLocationToEdgeOfSphere", result, bOutDidProject, ForLocation, SphereOrigin, SphereRadius, bOnlyProjectIfWithinRadius, bForceProjection2D, bDebug, DebugContextActor, DebugDuration); }
	static FVector * ProjectScreenLocationIntoWorld(FVector * result, APlayerController * ForPC, const FVector2D ScreenLocation, float ProjectionDist) { return NativeCall<FVector *, FVector *, APlayerController *, const FVector2D, float>(nullptr, "UVictoryCore.ProjectScreenLocationIntoWorld", result, ForPC, ScreenLocation, ProjectionDist); }
	static FVector * ProjectVectorOntoInsideOfSphere(FVector * result, const FVector * ProjectVector, const FVector * ProjectVectorLocation, const FVector * SphereOrigin, const bool bOnlyProjectIfVectorIsLeavingSphere) { return NativeCall<FVector *, FVector *, const FVector *, const FVector *, const FVector *, const bool>(nullptr, "UVictoryCore.ProjectVectorOntoInsideOfSphere", result, ProjectVector, ProjectVectorLocation, SphereOrigin, bOnlyProjectIfVectorIsLeavingSphere); }
	static bool ProjectWorldLocationToScreenOrScreenEdgePosition(APlayerController * playerController, FVector WorldLocation, FVector2D * ScreenPosition, const float screenMarginPercent, bool widgetSpace, bool * OnScreen, const bool bAdjustWithScreenDPI) { return NativeCall<bool, APlayerController *, FVector, FVector2D *, const float, bool, bool *, const bool>(nullptr, "UVictoryCore.ProjectWorldLocationToScreenOrScreenEdgePosition", playerController, WorldLocation, ScreenPosition, screenMarginPercent, widgetSpace, OnScreen, bAdjustWithScreenDPI); }
	static bool ProjectWorldToScreenPositionRaw(APlayerController * ThePC, FVector WorldLocation, FVector2D * Out_ScreenLocation, FVector * Out_ViewLocation, FBox2D * Out_ViewRect, bool * Out_bIsScreenLocationInsideViewRect, bool bIgnoreScreenProjectionGlobalTransform) { return NativeCall<bool, APlayerController *, FVector, FVector2D *, FVector *, FBox2D *, bool *, bool>(nullptr, "UVictoryCore.ProjectWorldToScreenPositionRaw", ThePC, WorldLocation, Out_ScreenLocation, Out_ViewLocation, Out_ViewRect, Out_bIsScreenLocationInsideViewRect, bIgnoreScreenProjectionGlobalTransform); }
	static FVector * RandomPointInBoundingBoxFromStream(FVector * result, const FVector * Origin, const FVector * BoxExtent, const FRandomStream * Stream) { return NativeCall<FVector *, FVector *, const FVector *, const FVector *, const FRandomStream *>(nullptr, "UVictoryCore.RandomPointInBoundingBoxFromStream", result, Origin, BoxExtent, Stream); }
	static bool ReallySupportsShaderModel5() { return NativeCall<bool>(nullptr, "UVictoryCore.ReallySupportsShaderModel5"); }
	static void RecordMeshingMetrics(AActor * ForActor, bool bWasDestoryed) { NativeCall<void, AActor *, bool>(nullptr, "UVictoryCore.RecordMeshingMetrics", ForActor, bWasDestoryed); }
	static void RegisterComponentBP(UActorComponent * component) { NativeCall<void, UActorComponent *>(nullptr, "UVictoryCore.RegisterComponentBP", component); }
	static bool RemoveActorFromCustomActorList(UWorld * ForWorld, FName SearchCustomTag, AActor * ActorToRemove) { return NativeCall<bool, UWorld *, FName, AActor *>(nullptr, "UVictoryCore.RemoveActorFromCustomActorList", ForWorld, SearchCustomTag, ActorToRemove); }
	static void RemoveFromActorList(UWorld * ForWorld, int ActorListNum, AActor * ActorRef) { NativeCall<void, UWorld *, int, AActor *>(nullptr, "UVictoryCore.RemoveFromActorList", ForWorld, ActorListNum, ActorRef); }
	static TArray<TWeakObjectPtr<APrimalDinoCharacter>> * RemoveInvalidObjectsInContainer(TArray<TWeakObjectPtr<APrimalDinoCharacter>> * result, TArray<TWeakObjectPtr<APrimalDinoCharacter>> fContainer) { return NativeCall<TArray<TWeakObjectPtr<APrimalDinoCharacter>> *, TArray<TWeakObjectPtr<APrimalDinoCharacter>> *, TArray<TWeakObjectPtr<APrimalDinoCharacter>>>(nullptr, "UVictoryCore.RemoveInvalidObjectsInContainer", result, fContainer); }
	static FRotator * RemovePitchAndRollFromRotator(FRotator * result, const FRotator * FromRotator) { return NativeCall<FRotator *, FRotator *, const FRotator *>(nullptr, "UVictoryCore.RemovePitchAndRollFromRotator", result, FromRotator); }
	static FRotator * RemoveRollFromRotator(FRotator * result, const FRotator * FromRotator) { return NativeCall<FRotator *, FRotator *, const FRotator *>(nullptr, "UVictoryCore.RemoveRollFromRotator", result, FromRotator); }
	static void ResetCooldown(long double * OutCooldownClock) { NativeCall<void, long double *>(nullptr, "UVictoryCore.ResetCooldown", OutCooldownClock); }
	static void ResetMousePositionToCenter(APlayerController * controller) { NativeCall<void, APlayerController *>(nullptr, "UVictoryCore.ResetMousePositionToCenter", controller); }
	static void ReupdateCaptures(UWorld * forWorld, bool bReinitSkylights) { NativeCall<void, UWorld *, bool>(nullptr, "UVictoryCore.ReupdateCaptures", forWorld, bReinitSkylights); }
	static FVector * RotateDirToTargetWithAngleLimits(FVector * result, const FVector * RotateDir, const FVector * TowardsDir, const FRotator WithAngleLimits, const bool bForceZeroRoll) { return NativeCall<FVector *, FVector *, const FVector *, const FVector *, const FRotator, const bool>(nullptr, "UVictoryCore.RotateDirToTargetWithAngleLimits", result, RotateDir, TowardsDir, WithAngleLimits, bForceZeroRoll); }
	static FDateTime * SafeUTCNow(FDateTime * result) { return NativeCall<FDateTime *, FDateTime *>(nullptr, "UVictoryCore.SafeUTCNow", result); }
	static bool SaveWorld(UWorld * World, float unlessLastSaveWorldWasWithinSeconds) { return NativeCall<bool, UWorld *, float>(nullptr, "UVictoryCore.SaveWorld", World, unlessLastSaveWorldWasWithinSeconds); }
	static FVector * SelectCloserVector(FVector * result, FVector Origin, FVector A, FVector B, bool * OutPickedA) { return NativeCall<FVector *, FVector *, FVector, FVector, FVector, bool *>(nullptr, "UVictoryCore.SelectCloserVector", result, Origin, A, B, OutPickedA); }
	static FVector * SelectVectorIfWithinRange(FVector * result, FVector A, FVector B, bool * OutPickedA, float MaxDistance) { return NativeCall<FVector *, FVector *, FVector, FVector, bool *, float>(nullptr, "UVictoryCore.SelectVectorIfWithinRange", result, A, B, OutPickedA, MaxDistance); }
	static bool ServerCheckMeshingOnActor(AActor * OnActor, bool bForceUseActorCenterBounds) { return NativeCall<bool, AActor *, bool>(nullptr, "UVictoryCore.ServerCheckMeshingOnActor", OnActor, bForceUseActorCenterBounds); }
	static void ServerSearchFoliage(UObject * WorldContextObject, FVector Origin, float Radius, TArray<FOverlappedFoliageElement> * OutFoliage, bool bVisibleAndActiveOnly, bool bIncludeUsableFoliage, bool bIncludeMeshFoliage, bool bSortByDistance, bool bReverseSort) { NativeCall<void, UObject *, FVector, float, TArray<FOverlappedFoliageElement> *, bool, bool, bool, bool, bool>(nullptr, "UVictoryCore.ServerSearchFoliage", WorldContextObject, Origin, Radius, OutFoliage, bVisibleAndActiveOnly, bIncludeUsableFoliage, bIncludeMeshFoliage, bSortByDistance, bReverseSort); }
	static void ServerSearchFoliageByResource(UObject * WorldContextObject, FVector Origin, float Radius, TArray<FOverlappedFoliageElement> * OutFoliage, const TArray<TSubclassOf<UPrimalItem>> * HarvestResources, bool bVisibleAndActiveOnly, bool bIncludeUsableFoliage, bool bIncludeMeshFoliage, bool bSortByDistance, bool bReverseSort) { NativeCall<void, UObject *, FVector, float, TArray<FOverlappedFoliageElement> *, const TArray<TSubclassOf<UPrimalItem>> *, bool, bool, bool, bool, bool>(nullptr, "UVictoryCore.ServerSearchFoliageByResource", WorldContextObject, Origin, Radius, OutFoliage, HarvestResources, bVisibleAndActiveOnly, bIncludeUsableFoliage, bIncludeMeshFoliage, bSortByDistance, bReverseSort); }
	static void SetAllowControllerInputWithCursor(bool bAllow) { NativeCall<void, bool>(nullptr, "UVictoryCore.SetAllowControllerInputWithCursor", bAllow); }
	static void SetBoolArrayElemFalse(TArray<bool> * TheArray, int TheIndex) { NativeCall<void, TArray<bool> *, int>(nullptr, "UVictoryCore.SetBoolArrayElemFalse", TheArray, TheIndex); }
	static void SetBoolArrayElemTrue(TArray<bool> * TheArray, int TheIndex) { NativeCall<void, TArray<bool> *, int>(nullptr, "UVictoryCore.SetBoolArrayElemTrue", TheArray, TheIndex); }
	static void SetDinoSetupPointsPerStat(FDinoSetup * DinoSetup, TEnumAsByte<enum EPrimalCharacterStatusValue::Type> StatusType, int Value, bool bIsPlayerAdded, bool bAddInsteadOfSet) { NativeCall<void, FDinoSetup *, TEnumAsByte<enum EPrimalCharacterStatusValue::Type>, int, bool, bool>(nullptr, "UVictoryCore.SetDinoSetupPointsPerStat", DinoSetup, StatusType, Value, bIsPlayerAdded, bAddInsteadOfSet); }
	static void SetLastHostedMapPlayed(const FString * NewLastHostedMapPlayed) { NativeCall<void, const FString *>(nullptr, "UVictoryCore.SetLastHostedMapPlayed", NewLastHostedMapPlayed); }
	static void SetLastMapPlayed(const FString * NewLastMapPlayed) { NativeCall<void, const FString *>(nullptr, "UVictoryCore.SetLastMapPlayed", NewLastMapPlayed); }
	static void SetMaterialColorizationFromItemColors(UPrimalItem * item, UMaterialInstanceDynamic * dynamicMic) { NativeCall<void, UPrimalItem *, UMaterialInstanceDynamic *>(nullptr, "UVictoryCore.SetMaterialColorizationFromItemColors", item, dynamicMic); }
	static void SetMousePosition(APlayerController * controller, float X, float Y) { NativeCall<void, APlayerController *, float, float>(nullptr, "UVictoryCore.SetMousePosition", controller, X, Y); }
	static bool SetMultiUseEntryPriority(TArray<FMultiUseEntry> * InOutEntries, bool bFindByUseIndexInsteadOfArrayIndex, int Index, int NewPriority) { return NativeCall<bool, TArray<FMultiUseEntry> *, bool, int, int>(nullptr, "UVictoryCore.SetMultiUseEntryPriority", InOutEntries, bFindByUseIndexInsteadOfArrayIndex, Index, NewPriority); }
	static void SetSelectedLevelActors(TArray<AActor *> ActorsToSelect, bool bClearPreviousSelection) { NativeCall<void, TArray<AActor *>, bool>(nullptr, "UVictoryCore.SetSelectedLevelActors", ActorsToSelect, bClearPreviousSelection); }
	static void SetSessionPrefix(const FString * InPrefix) { NativeCall<void, const FString *>(nullptr, "UVictoryCore.SetSessionPrefix", InPrefix); }
	static void SetTickGroupBP(UActorComponent * component, ETickingGroup tickGroup) { NativeCall<void, UActorComponent *, ETickingGroup>(nullptr, "UVictoryCore.SetTickGroupBP", component, tickGroup); }
	static void ShowEditorNotification(UObject * WorldContextObject, FString Message, TEnumAsByte<enum EEditorMessageLogLevel::Type> LogLevel, float Duration, bool bServerOnly) { NativeCall<void, UObject *, FString, TEnumAsByte<enum EEditorMessageLogLevel::Type>, float, bool>(nullptr, "UVictoryCore.ShowEditorNotification", WorldContextObject, Message, LogLevel, Duration, bServerOnly); }
	static float SimpleCurveEval(float Value, TEnumAsByte<enum ESimpleCurve::Type> CurveType) { return NativeCall<float, float, TEnumAsByte<enum ESimpleCurve::Type>>(nullptr, "UVictoryCore.SimpleCurveEval", Value, CurveType); }
	static float SimpleCurveInterpClamped(float A, float B, float Alpha, TEnumAsByte<enum ESimpleCurve::Type> CurveType) { return NativeCall<float, float, float, float, TEnumAsByte<enum ESimpleCurve::Type>>(nullptr, "UVictoryCore.SimpleCurveInterpClamped", A, B, Alpha, CurveType); }
	static FLinearColor * SimpleCurveInterpClampedLinearColor(FLinearColor * result, FLinearColor A, FLinearColor B, float Alpha, TEnumAsByte<enum ESimpleCurve::Type> CurveType) { return NativeCall<FLinearColor *, FLinearColor *, FLinearColor, FLinearColor, float, TEnumAsByte<enum ESimpleCurve::Type>>(nullptr, "UVictoryCore.SimpleCurveInterpClampedLinearColor", result, A, B, Alpha, CurveType); }
	static FRotator * SimpleCurveInterpClampedRotator(FRotator * result, FRotator A, FRotator B, float Alpha, bool bShortestPath, TEnumAsByte<enum ESimpleCurve::Type> CurveType) { return NativeCall<FRotator *, FRotator *, FRotator, FRotator, float, bool, TEnumAsByte<enum ESimpleCurve::Type>>(nullptr, "UVictoryCore.SimpleCurveInterpClampedRotator", result, A, B, Alpha, bShortestPath, CurveType); }
	static FTransform * SimpleCurveInterpClampedTransform(FTransform * result, FTransform A, FTransform B, float Alpha, TEnumAsByte<enum ESimpleCurve::Type> CurveType) { return NativeCall<FTransform *, FTransform *, FTransform, FTransform, float, TEnumAsByte<enum ESimpleCurve::Type>>(nullptr, "UVictoryCore.SimpleCurveInterpClampedTransform", result, A, B, Alpha, CurveType); }
	static FVector * SimpleCurveInterpClampedVector(FVector * result, FVector A, FVector B, float Alpha, TEnumAsByte<enum ESimpleCurve::Type> CurveType) { return NativeCall<FVector *, FVector *, FVector, FVector, float, TEnumAsByte<enum ESimpleCurve::Type>>(nullptr, "UVictoryCore.SimpleCurveInterpClampedVector", result, A, B, Alpha, CurveType); }
	static FString * SimpleFloatString(FString * result, float inputVal) { return NativeCall<FString *, FString *, float>(nullptr, "UVictoryCore.SimpleFloatString", result, inputVal); }
	static FString * SimpleReplaceUnicodeWithSupportedAlternatives(FString * result, const FString * OriginalString) { return NativeCall<FString *, FString *, const FString *>(nullptr, "UVictoryCore.SimpleReplaceUnicodeWithSupportedAlternatives", result, OriginalString); }
	static TArray<FVector> * SortPointsByDistance(TArray<FVector> * result, const FVector * fromLoc, const TArray<FVector> * points) { return NativeCall<TArray<FVector> *, TArray<FVector> *, const FVector *, const TArray<FVector> *>(nullptr, "UVictoryCore.SortPointsByDistance", result, fromLoc, points); }
	static APrimalDinoCharacter * SpawnCustomDino(UWorld * World, const FVector * SpawnLocation, const FRotator * SpawnRotation, const FDinoSetup * DinoSetup, AShooterPlayerController * OwnerPlayerController, float DebugDrawDuration, bool bApplyRotationToSpawnOffset, bool bUseExactSpawnLocation, bool bSkipAddingTamedLevels, bool bSuppressTamingNotifications, AMissionType * mission, TSubclassOf<UPrimalColorSet> ColorSet) { return NativeCall<APrimalDinoCharacter *, UWorld *, const FVector *, const FRotator *, const FDinoSetup *, AShooterPlayerController *, float, bool, bool, bool, bool, AMissionType *, TSubclassOf<UPrimalColorSet>>(nullptr, "UVictoryCore.SpawnCustomDino", World, SpawnLocation, SpawnRotation, DinoSetup, OwnerPlayerController, DebugDrawDuration, bApplyRotationToSpawnOffset, bUseExactSpawnLocation, bSkipAddingTamedLevels, bSuppressTamingNotifications, mission, ColorSet); }
	static bool SphereOverlapFast(UObject * WorldContextObject, const FVector * Loc, const float Radius) { return NativeCall<bool, UObject *, const FVector *, const float>(nullptr, "UVictoryCore.SphereOverlapFast", WorldContextObject, Loc, Radius); }
	static bool SplineLineTrace(USplineComponent * SplineComponent, const TArray<AActor *> * ActorsToIgnore, TArray<FHitResult> * OutHits, int NumTracesPerSegment, ECollisionChannel Channel, bool bStopOnBlockingHit, float DebugDrawDuration) { return NativeCall<bool, USplineComponent *, const TArray<AActor *> *, TArray<FHitResult> *, int, ECollisionChannel, bool, float>(nullptr, "UVictoryCore.SplineLineTrace", SplineComponent, ActorsToIgnore, OutHits, NumTracesPerSegment, Channel, bStopOnBlockingHit, DebugDrawDuration); }
	static void StartCompanionEventForPlayer(APrimalCharacter * Player, FCompanionEventData * EventData, AActor * EventActor) { NativeCall<void, APrimalCharacter *, FCompanionEventData *, AActor *>(nullptr, "UVictoryCore.StartCompanionEventForPlayer", Player, EventData, EventActor); }
	static bool StaticCheckForCommand(FString CommandName) { return NativeCall<bool, FString>(nullptr, "UVictoryCore.StaticCheckForCommand", CommandName); }
	static float StaticGetTimeSince(UWorld * ForWorld, long double OldTime) { return NativeCall<float, UWorld *, long double>(nullptr, "UVictoryCore.StaticGetTimeSince", ForWorld, OldTime); }
	static void SteamOverlayOpenURL(const FString * ToURL) { NativeCall<void, const FString *>(nullptr, "UVictoryCore.SteamOverlayOpenURL", ToURL); }
	static void StopCompanionEventForPlayer(APrimalCharacter * Player) { NativeCall<void, APrimalCharacter *>(nullptr, "UVictoryCore.StopCompanionEventForPlayer", Player); }
	static int StringToIntAscii(FString SourceString, int Index) { return NativeCall<int, FString, int>(nullptr, "UVictoryCore.StringToIntAscii", SourceString, Index); }
	static bool SupportsShaderModel5() { return NativeCall<bool>(nullptr, "UVictoryCore.SupportsShaderModel5"); }
	static long double TimeSeconds(UWorld * ForWorld) { return NativeCall<long double, UWorld *>(nullptr, "UVictoryCore.TimeSeconds", ForWorld); }
	static float TimeSince_Network(UWorld * ForWorld, long double OldTime) { return NativeCall<float, UWorld *, long double>(nullptr, "UVictoryCore.TimeSince_Network", ForWorld, OldTime); }
	static float TimeSince_Utc(long double OldTime) { return NativeCall<float, long double>(nullptr, "UVictoryCore.TimeSince_Utc", OldTime); }
	static bool TraceProjectileArc(UObject * WorldContextObject, const FProjectileArc * Arc, FHitResult * OutHitResult, FVector * OutEndLocation, float * OutEndArcTime, FVector * OutArcPeakLocation, float MaxArcLength, const TArray<AActor *> * ActorsToIgnore, float ArcTimeStep, ECollisionChannel CollisionChannel, bool bTraceObjectTypeOnly, bool bDrawDebug, float DebugDrawDuration) { return NativeCall<bool, UObject *, const FProjectileArc *, FHitResult *, FVector *, float *, FVector *, float, const TArray<AActor *> *, float, ECollisionChannel, bool, bool, float>(nullptr, "UVictoryCore.TraceProjectileArc", WorldContextObject, Arc, OutHitResult, OutEndLocation, OutEndArcTime, OutArcPeakLocation, MaxArcLength, ActorsToIgnore, ArcTimeStep, CollisionChannel, bTraceObjectTypeOnly, bDrawDebug, DebugDrawDuration); }
	static FVector2D * TransformVectorByScreenProjectionGlobalTransform(FVector2D * result, const FVector2D vec) { return NativeCall<FVector2D *, FVector2D *, const FVector2D>(nullptr, "UVictoryCore.TransformVectorByScreenProjectionGlobalTransform", result, vec); }
	static void TrimArray_Float(TArray<float> * InOutArray, int MaxLength, bool bRemoveFromEnd) { NativeCall<void, TArray<float> *, int, bool>(nullptr, "UVictoryCore.TrimArray_Float", InOutArray, MaxLength, bRemoveFromEnd); }
	static void TrimArray_Vector(TArray<FVector> * InOutArray, int MaxLength, bool bRemoveFromEnd) { NativeCall<void, TArray<FVector> *, int, bool>(nullptr, "UVictoryCore.TrimArray_Vector", InOutArray, MaxLength, bRemoveFromEnd); }
	static bool TryGetLocalizedString(FString Namespace, FString StringToLocalize, FString * OutLocalizedVersion) { return NativeCall<bool, FString, FString, FString *>(nullptr, "UVictoryCore.TryGetLocalizedString", Namespace, StringToLocalize, OutLocalizedVersion); }
	static void UnPauseTimer(UObject * Object, FString FunctionName) { NativeCall<void, UObject *, FString>(nullptr, "UVictoryCore.UnPauseTimer", Object, FunctionName); }
	static void UnRegisterComponentBP(UActorComponent * component) { NativeCall<void, UActorComponent *>(nullptr, "UVictoryCore.UnRegisterComponentBP", component); }
	static void UseCooldown(UObject * WorldContextObject, long double * OutCooldownClock) { NativeCall<void, UObject *, long double *>(nullptr, "UVictoryCore.UseCooldown", WorldContextObject, OutCooldownClock); }
	static bool VTraceAgainstActorExpensive(UWorld * theWorld, const FVector * Start, const FVector * End, FHitResult * HitOut, AActor * ActorToTraceAgainst, ECollisionChannel Channel, int CollisionGroups, float SphereRadius, bool bReturnPhysMaterial, bool bTraceComplex, const FVector * BoxExtent, FName TraceTag, bool bSort) { return NativeCall<bool, UWorld *, const FVector *, const FVector *, FHitResult *, AActor *, ECollisionChannel, int, float, bool, bool, const FVector *, FName, bool>(nullptr, "UVictoryCore.VTraceAgainstActorExpensive", theWorld, Start, End, HitOut, ActorToTraceAgainst, Channel, CollisionGroups, SphereRadius, bReturnPhysMaterial, bTraceComplex, BoxExtent, TraceTag, bSort); }
	static bool VTraceIgnoreFoliage(UWorld * theWorld, const FVector * Start, const FVector * End, FHitResult * HitOut, AActor * ActorToIgnore, ECollisionChannel Channel, int CollisionGroups, bool bReturnPhysMaterial, bool bTraceComplex, const FVector * BoxExtent, FName TraceTag, AActor * OtherActorToIgnore, TArray<AActor *> * OtherActorsToIgnore, const FQuat * Rot, AActor * AnotherActorToIgnore, bool bIgnoreFoliage) { return NativeCall<bool, UWorld *, const FVector *, const FVector *, FHitResult *, AActor *, ECollisionChannel, int, bool, bool, const FVector *, FName, AActor *, TArray<AActor *> *, const FQuat *, AActor *, bool>(nullptr, "UVictoryCore.VTraceIgnoreFoliage", theWorld, Start, End, HitOut, ActorToIgnore, Channel, CollisionGroups, bReturnPhysMaterial, bTraceComplex, BoxExtent, TraceTag, OtherActorToIgnore, OtherActorsToIgnore, Rot, AnotherActorToIgnore, bIgnoreFoliage); }
	static bool VTraceMulti(UWorld * theWorld, TArray<FHitResult> * OutHits, const FVector * Start, const FVector * End, AActor * InIgnoreActor, int CollisionGroups, float SphereRadius, const FVector * BoxExtent, bool bReturnPhysMaterial, ECollisionChannel TraceChannel, bool bTraceComplex, FName TraceTag, bool bTraceChannelForceOverlap, bool bDoSort, AActor * AdditionalIgnoreActor, AActor * AnotherIgnoreActor, bool bJustDoSphereOverlapAtStartLoc, TArray<AActor *> * ExtraIgnoreActors) { return NativeCall<bool, UWorld *, TArray<FHitResult> *, const FVector *, const FVector *, AActor *, int, float, const FVector *, bool, ECollisionChannel, bool, FName, bool, bool, AActor *, AActor *, bool, TArray<AActor *> *>(nullptr, "UVictoryCore.VTraceMulti", theWorld, OutHits, Start, End, InIgnoreActor, CollisionGroups, SphereRadius, BoxExtent, bReturnPhysMaterial, TraceChannel, bTraceComplex, TraceTag, bTraceChannelForceOverlap, bDoSort, AdditionalIgnoreActor, AnotherIgnoreActor, bJustDoSphereOverlapAtStartLoc, ExtraIgnoreActors); }
	static bool VTraceMultiBP(UWorld * theWorld, TArray<FHitResult> * OutHits, const FVector * Start, const FVector * End, AActor * InIgnoreActor, int CollisionGroups, float SphereRadius, const FVector * BoxExtent, bool bReturnPhysMaterial, ECollisionChannel TraceChannel, bool bTraceComplex, FName TraceTag, bool bTraceChannelForceOverlap, bool bDoSort, AActor * AdditionalIgnoreActor, AActor * AnotherIgnoreActor, bool bJustDoSphereOverlapAtStartLoc, float DebugDrawDuration) { return NativeCall<bool, UWorld *, TArray<FHitResult> *, const FVector *, const FVector *, AActor *, int, float, const FVector *, bool, ECollisionChannel, bool, FName, bool, bool, AActor *, AActor *, bool, float>(nullptr, "UVictoryCore.VTraceMultiBP", theWorld, OutHits, Start, End, InIgnoreActor, CollisionGroups, SphereRadius, BoxExtent, bReturnPhysMaterial, TraceChannel, bTraceComplex, TraceTag, bTraceChannelForceOverlap, bDoSort, AdditionalIgnoreActor, AnotherIgnoreActor, bJustDoSphereOverlapAtStartLoc, DebugDrawDuration); }
	static bool VTraceMultiBP_IgnoreActorsArray(UWorld * theWorld, TArray<FHitResult> * OutHits, const FVector * Start, const FVector * End, const TArray<AActor *> * ExtraIgnoreActors, AActor * InIgnoreActor, int CollisionGroups, float SphereRadius, const FVector * BoxExtent, bool bReturnPhysMaterial, ECollisionChannel TraceChannel, bool bTraceComplex, FName TraceTag, bool bTraceChannelForceOverlap, bool bDoSort, bool bJustDoSphereOverlapAtStartLoc, float DebugDrawDuration) { return NativeCall<bool, UWorld *, TArray<FHitResult> *, const FVector *, const FVector *, const TArray<AActor *> *, AActor *, int, float, const FVector *, bool, ECollisionChannel, bool, FName, bool, bool, bool, float>(nullptr, "UVictoryCore.VTraceMultiBP_IgnoreActorsArray", theWorld, OutHits, Start, End, ExtraIgnoreActors, InIgnoreActor, CollisionGroups, SphereRadius, BoxExtent, bReturnPhysMaterial, TraceChannel, bTraceComplex, TraceTag, bTraceChannelForceOverlap, bDoSort, bJustDoSphereOverlapAtStartLoc, DebugDrawDuration); }
	static bool VTraceShapeBP(UWorld * theWorld, const FVector * Start, const FVector * End, FHitResult * HitOut, const TArray<AActor *> * ExtraIgnoreActors, AActor * InIgnoreActor, const float ShapeRadius, const float ShapeHalfHeight, const FVector ShapeBoxExtent, const FRotator ShapeRotation, ECollisionChannel Channel, int CollisionGroups, bool bReturnPhysMaterial, bool bTraceComplex, FName TraceTag, float DebugDrawDuration) { return NativeCall<bool, UWorld *, const FVector *, const FVector *, FHitResult *, const TArray<AActor *> *, AActor *, const float, const float, const FVector, const FRotator, ECollisionChannel, int, bool, bool, FName, float>(nullptr, "UVictoryCore.VTraceShapeBP", theWorld, Start, End, HitOut, ExtraIgnoreActors, InIgnoreActor, ShapeRadius, ShapeHalfHeight, ShapeBoxExtent, ShapeRotation, Channel, CollisionGroups, bReturnPhysMaterial, bTraceComplex, TraceTag, DebugDrawDuration); }
	static bool VTraceShapeMultiBP(UWorld * theWorld, TArray<FHitResult> * OutHits, const FVector * Start, const FVector * End, const TArray<AActor *> * ExtraIgnoreActors, AActor * InIgnoreActor, const float ShapeRadius, const float ShapeHalfHeight, const FVector ShapeBoxExtent, const FRotator ShapeRotation, ECollisionChannel Channel, int CollisionGroups, bool bReturnPhysMaterial, bool bTraceComplex, FName TraceTag, float DebugDrawDuration) { return NativeCall<bool, UWorld *, TArray<FHitResult> *, const FVector *, const FVector *, const TArray<AActor *> *, AActor *, const float, const float, const FVector, const FRotator, ECollisionChannel, int, bool, bool, FName, float>(nullptr, "UVictoryCore.VTraceShapeMultiBP", theWorld, OutHits, Start, End, ExtraIgnoreActors, InIgnoreActor, ShapeRadius, ShapeHalfHeight, ShapeBoxExtent, ShapeRotation, Channel, CollisionGroups, bReturnPhysMaterial, bTraceComplex, TraceTag, DebugDrawDuration); }
	static bool VTraceSingleBP(UWorld * theWorld, FHitResult * OutHit, const FVector * Start, const FVector * End, ECollisionChannel TraceChannel, int CollisionGroups, FName TraceTag, bool bTraceComplex, AActor * ActorToIgnore, float DebugDrawDuration) { return NativeCall<bool, UWorld *, FHitResult *, const FVector *, const FVector *, ECollisionChannel, int, FName, bool, AActor *, float>(nullptr, "UVictoryCore.VTraceSingleBP", theWorld, OutHit, Start, End, TraceChannel, CollisionGroups, TraceTag, bTraceComplex, ActorToIgnore, DebugDrawDuration); }
	static bool VTraceSingleBP_IgnoreActorsArray(UWorld * theWorld, FHitResult * OutHit, const FVector * Start, const FVector * End, const TArray<AActor *> * ExtraIgnoreActors, AActor * InIgnoreActor, ECollisionChannel TraceChannel, int CollisionGroups, FName TraceTag, bool bReturnPhysMaterial, bool bTraceComplex, float DebugDrawDuration) { return NativeCall<bool, UWorld *, FHitResult *, const FVector *, const FVector *, const TArray<AActor *> *, AActor *, ECollisionChannel, int, FName, bool, bool, float>(nullptr, "UVictoryCore.VTraceSingleBP_IgnoreActorsArray", theWorld, OutHit, Start, End, ExtraIgnoreActors, InIgnoreActor, TraceChannel, CollisionGroups, TraceTag, bReturnPhysMaterial, bTraceComplex, DebugDrawDuration); }
	static bool VTraceSphereBP(UWorld * theWorld, const FVector * Start, const FVector * End, FHitResult * HitOut, float Radius, AActor * ActorToIgnore, ECollisionChannel Channel, int CollisionGroups, bool bReturnPhysMaterial, bool bTraceComplex, FName TraceTag, AActor * OtherActorToIgnore, AActor * AnotherActorToIgnore, float DebugDrawDuration) { return NativeCall<bool, UWorld *, const FVector *, const FVector *, FHitResult *, float, AActor *, ECollisionChannel, int, bool, bool, FName, AActor *, AActor *, float>(nullptr, "UVictoryCore.VTraceSphereBP", theWorld, Start, End, HitOut, Radius, ActorToIgnore, Channel, CollisionGroups, bReturnPhysMaterial, bTraceComplex, TraceTag, OtherActorToIgnore, AnotherActorToIgnore, DebugDrawDuration); }
	static bool VTraceSphereBP_IgnoreActorsArray(UWorld * theWorld, const FVector * Start, const FVector * End, FHitResult * HitOut, float Radius, const TArray<AActor *> * ExtraIgnoreActors, AActor * InIgnoreActor, ECollisionChannel Channel, int CollisionGroups, bool bReturnPhysMaterial, bool bTraceComplex, FName TraceTag, float DebugDrawDuration) { return NativeCall<bool, UWorld *, const FVector *, const FVector *, FHitResult *, float, const TArray<AActor *> *, AActor *, ECollisionChannel, int, bool, bool, FName, float>(nullptr, "UVictoryCore.VTraceSphereBP_IgnoreActorsArray", theWorld, Start, End, HitOut, Radius, ExtraIgnoreActors, InIgnoreActor, Channel, CollisionGroups, bReturnPhysMaterial, bTraceComplex, TraceTag, DebugDrawDuration); }
	static float VectorDistance(FVector A, FVector B) { return NativeCall<float, FVector, FVector>(nullptr, "UVictoryCore.VectorDistance", A, B); }
	static FVector * ViewDirectionAngleOffset(FVector * result, FVector ViewDirection, FVector RightVector, float AngleOffsetDegrees, float MaxAngleDegreesBeforeInterpToUp) { return NativeCall<FVector *, FVector *, FVector, FVector, float, float>(nullptr, "UVictoryCore.ViewDirectionAngleOffset", result, ViewDirection, RightVector, AngleOffsetDegrees, MaxAngleDegreesBeforeInterpToUp); }
	static void ViewTrailer(bool bAnimatedSeriesTrailer, bool bARK2Trailer) { NativeCall<void, bool, bool>(nullptr, "UVictoryCore.ViewTrailer", bAnimatedSeriesTrailer, bARK2Trailer); }
	static void VisualLog_LineSegment(AActor * Actor, FString Message, bool bIsError, FVector Location, FLinearColor Color, float Size, bool bAlsoPrintMessage) { NativeCall<void, AActor *, FString, bool, FVector, FLinearColor, float, bool>(nullptr, "UVictoryCore.VisualLog_LineSegment", Actor, Message, bIsError, Location, Color, Size, bAlsoPrintMessage); }
	static void VisualLog_Print(AActor * Actor, FString Message, bool bIsError) { NativeCall<void, AActor *, FString, bool>(nullptr, "UVictoryCore.VisualLog_Print", Actor, Message, bIsError); }
	static FRotator * RLerp(FRotator * result, FRotator A, FRotator B, float Alpha, bool bShortestPath) { return NativeCall<FRotator *, FRotator *, FRotator, FRotator, float, bool>(nullptr, "UVictoryCore.RLerp", result, A, B, Alpha, bShortestPath); }
};

