#pragma once

#include "BaseDeclarations.h"
#include "UBlueprintFunctionLibrary.h"
#include "UObject.h"
#include "UObjectBaseUtility.h"
#include "UObjectBase.h"
#include "FAvoidanceArea.h"
#include "FBoid.h"

struct UFlockingBehavior : UBlueprintFunctionLibrary
{

	// Functions

	static void AddAvoidanceAreaToFlockData(FFlockPersistentData * InOutFlockData, FAvoidanceArea Area) { NativeCall<void, FFlockPersistentData *, FAvoidanceArea>(nullptr, "UFlockingBehavior.AddAvoidanceAreaToFlockData", InOutFlockData, Area); }
	static void BoidMoveTo(int BoidIndex, TArray<FBoid> * InOutBoidArray, FFlockPersistentData * InOutFlockData, const FBoidBehavior * Behavior, float DeltaTime, const FVector * NewWorldLocation, float TargetDistanceThreshold, bool bUseIterp, float InterpSpeed) { NativeCall<void, int, TArray<FBoid> *, FFlockPersistentData *, const FBoidBehavior *, float, const FVector *, float, bool, float>(nullptr, "UFlockingBehavior.BoidMoveTo", BoidIndex, InOutBoidArray, InOutFlockData, Behavior, DeltaTime, NewWorldLocation, TargetDistanceThreshold, bUseIterp, InterpSpeed); }
	static void BoidSetAlive(int BoidIndex, TArray<FBoid> * InOutBoidArray, bool bIsAlive) { NativeCall<void, int, TArray<FBoid> *, bool>(nullptr, "UFlockingBehavior.BoidSetAlive", BoidIndex, InOutBoidArray, bIsAlive); }
	static void BoidSetTarget(int BoidIndex, TArray<FBoid> * InOutBoidArray, FVector TargetWorldLocation) { NativeCall<void, int, TArray<FBoid> *, FVector>(nullptr, "UFlockingBehavior.BoidSetTarget", BoidIndex, InOutBoidArray, TargetWorldLocation); }
	static void BoidStopTargeting(int BoidIndex, TArray<FBoid> * InOutBoidArray) { NativeCall<void, int, TArray<FBoid> *>(nullptr, "UFlockingBehavior.BoidStopTargeting", BoidIndex, InOutBoidArray); }
	static void BoidTick(int BoidIndex, TArray<FBoid> * InOutBoidArray, FFlockPersistentData * InOutFlockData, float DeltaTime, const FBoidBehavior * Behavior) { NativeCall<void, int, TArray<FBoid> *, FFlockPersistentData *, float, const FBoidBehavior *>(nullptr, "UFlockingBehavior.BoidTick", BoidIndex, InOutBoidArray, InOutFlockData, DeltaTime, Behavior); }
	static void DrawDebugAvoidanceArea(UObject * WorldContextObject, const FAvoidanceArea * Area, float DrawDuration) { NativeCall<void, UObject *, const FAvoidanceArea *, float>(nullptr, "UFlockingBehavior.DrawDebugAvoidanceArea", WorldContextObject, Area, DrawDuration); }
	static void FlockCreate(TArray<FBoid> * OutNewBoids, const FTransform * WorldTransform, int NumFlockBoids, int NumLeaderBoids, float InitialSpawnRadius, FVector2D MaxSpeedRange, FVector2D MaxForceRange, FVector2D TurnRateRange) { NativeCall<void, TArray<FBoid> *, const FTransform *, int, int, float, FVector2D, FVector2D, FVector2D>(nullptr, "UFlockingBehavior.FlockCreate", OutNewBoids, WorldTransform, NumFlockBoids, NumLeaderBoids, InitialSpawnRadius, MaxSpeedRange, MaxForceRange, TurnRateRange); }
	static void FlockSetMaxSpeedAndForce(TArray<FBoid> * InOutBoidArray, bool bUseBoidIndexWhitelist, const TArray<int> * BoidIndexWhitelist, FVector2D MaxSpeedRange, FVector2D MaxForceRange) { NativeCall<void, TArray<FBoid> *, bool, const TArray<int> *, FVector2D, FVector2D>(nullptr, "UFlockingBehavior.FlockSetMaxSpeedAndForce", InOutBoidArray, bUseBoidIndexWhitelist, BoidIndexWhitelist, MaxSpeedRange, MaxForceRange); }
	static void FlockTickCircleFormation(TArray<FBoid> * InOutBoidArray, FFlockPersistentData * InOutFlockData, bool bUseBoidIndexWhitelist, const TArray<int> * BoidIndexWhitelist, float DeltaTime, const FTransform * WorldTransform, const FBoidBehavior * Behavior, FRotator CircleRotation, float CircleRadius, float MinInterpDistance) { NativeCall<void, TArray<FBoid> *, FFlockPersistentData *, bool, const TArray<int> *, float, const FTransform *, const FBoidBehavior *, FRotator, float, float>(nullptr, "UFlockingBehavior.FlockTickCircleFormation", InOutBoidArray, InOutFlockData, bUseBoidIndexWhitelist, BoidIndexWhitelist, DeltaTime, WorldTransform, Behavior, CircleRotation, CircleRadius, MinInterpDistance); }
	static void FlockTickFollowersAndFreeAgents(TArray<FBoid> * InOutBoidArray, FFlockPersistentData * InOutFlockData, bool bUseBoidIndexWhitelist, const TArray<int> * BoidIndexWhitelist, float DeltaTime, const FBoidBehavior * Behavior) { NativeCall<void, TArray<FBoid> *, FFlockPersistentData *, bool, const TArray<int> *, float, const FBoidBehavior *>(nullptr, "UFlockingBehavior.FlockTickFollowersAndFreeAgents", InOutBoidArray, InOutFlockData, bUseBoidIndexWhitelist, BoidIndexWhitelist, DeltaTime, Behavior); }
	static void FlockTickGridFormation(TArray<FBoid> * InOutBoidArray, FFlockPersistentData * InOutFlockData, bool bUseBoidIndexWhitelist, const TArray<int> * BoidIndexWhitelist, float DeltaTime, const FTransform * WorldTransform, const FBoidBehavior * Behavior, float MinInterpDistance, FRotator GridRotation, float GridHorizSize, float GridVertSize, int GridNumRows, int GridNumCols) { NativeCall<void, TArray<FBoid> *, FFlockPersistentData *, bool, const TArray<int> *, float, const FTransform *, const FBoidBehavior *, float, FRotator, float, float, int, int>(nullptr, "UFlockingBehavior.FlockTickGridFormation", InOutBoidArray, InOutFlockData, bUseBoidIndexWhitelist, BoidIndexWhitelist, DeltaTime, WorldTransform, Behavior, MinInterpDistance, GridRotation, GridHorizSize, GridVertSize, GridNumRows, GridNumCols); }
	static void FlockTickLeaders(TArray<FBoid> * InOutBoidArray, FFlockPersistentData * InOutFlockData, bool bUseBoidIndexWhitelist, const TArray<int> * BoidIndexWhitelist, float DeltaTime, const FTransform * ParentTransform, float LeaderInterpSpeed, float LeaderAreaWidth) { NativeCall<void, TArray<FBoid> *, FFlockPersistentData *, bool, const TArray<int> *, float, const FTransform *, float, float>(nullptr, "UFlockingBehavior.FlockTickLeaders", InOutBoidArray, InOutFlockData, bUseBoidIndexWhitelist, BoidIndexWhitelist, DeltaTime, ParentTransform, LeaderInterpSpeed, LeaderAreaWidth); }
	static void FlockTickSphereFormation(TArray<FBoid> * InOutBoidArray, FFlockPersistentData * InOutFlockData, bool bUseBoidIndexWhitelist, const TArray<int> * BoidIndexWhitelist, float DeltaTime, const FTransform * WorldTransform, const FBoidBehavior * Behavior, float MinInterpDistance, float Radius, int NumRows, TEnumAsByte<enum ESimpleCurve::Type> LatitudeDistribution, float HelixSpeed) { NativeCall<void, TArray<FBoid> *, FFlockPersistentData *, bool, const TArray<int> *, float, const FTransform *, const FBoidBehavior *, float, float, int, TEnumAsByte<enum ESimpleCurve::Type>, float>(nullptr, "UFlockingBehavior.FlockTickSphereFormation", InOutBoidArray, InOutFlockData, bUseBoidIndexWhitelist, BoidIndexWhitelist, DeltaTime, WorldTransform, Behavior, MinInterpDistance, Radius, NumRows, LatitudeDistribution, HelixSpeed); }
	static FVector * GetAvoidanceAreaWorldLocation(FVector * result, const FAvoidanceArea * Area) { return NativeCall<FVector *, FVector *, const FAvoidanceArea *>(nullptr, "UFlockingBehavior.GetAvoidanceAreaWorldLocation", result, Area); }
	static FVector * GetAvoidanceDirection(FVector * result, const FAvoidanceArea * Area, const FVector * CurrentLoc, const FVector * CurrentDir) { return NativeCall<FVector *, FVector *, const FAvoidanceArea *, const FVector *, const FVector *>(nullptr, "UFlockingBehavior.GetAvoidanceDirection", result, Area, CurrentLoc, CurrentDir); }
	static FVector * GetClosestSurfacePointOnAvoidanceArea(FVector * result, const FAvoidanceArea * Area, const FVector * Loc) { return NativeCall<FVector *, FVector *, const FAvoidanceArea *, const FVector *>(nullptr, "UFlockingBehavior.GetClosestSurfacePointOnAvoidanceArea", result, Area, Loc); }
	static FVector * GetFlockCentroid(FVector * result, const TArray<FBoid> * BoidArray, bool bIgnoreLeaders) { return NativeCall<FVector *, FVector *, const TArray<FBoid> *, bool>(nullptr, "UFlockingBehavior.GetFlockCentroid", result, BoidArray, bIgnoreLeaders); }
	static void GetFlockMembersOfType(const TArray<FBoid> * BoidArray, TEnumAsByte<enum EBoidType::Type> BoidType, TArray<int> * OutIndices) { NativeCall<void, const TArray<FBoid> *, TEnumAsByte<enum EBoidType::Type>, TArray<int> *>(nullptr, "UFlockingBehavior.GetFlockMembersOfType", BoidArray, BoidType, OutIndices); }
	static float GetFlockRadius(const TArray<FBoid> * BoidArray, const FVector * FlockCentroid, bool bIgnoreLeaders) { return NativeCall<float, const TArray<FBoid> *, const FVector *, bool>(nullptr, "UFlockingBehavior.GetFlockRadius", BoidArray, FlockCentroid, bIgnoreLeaders); }
	static void InterpBoidArray(TArray<FBoid> * InOutBoidArray, const TArray<FBoid> * RelativeTargets, const FTransform * WorldTransform, FRotator Rotation, float DeltaTime, float InterpSpeedMin, float InterpSpeedMax) { NativeCall<void, TArray<FBoid> *, const TArray<FBoid> *, const FTransform *, FRotator, float, float, float>(nullptr, "UFlockingBehavior.InterpBoidArray", InOutBoidArray, RelativeTargets, WorldTransform, Rotation, DeltaTime, InterpSpeedMin, InterpSpeedMax); }
	static void InterpBoidArrayToCircle(TArray<FBoid> * InOutBoidArray, const FTransform * WorldTransform, FRotator Rotation, float Radius, float DeltaTime, float InterpSpeedMin, float InterpSpeedMax) { NativeCall<void, TArray<FBoid> *, const FTransform *, FRotator, float, float, float, float>(nullptr, "UFlockingBehavior.InterpBoidArrayToCircle", InOutBoidArray, WorldTransform, Rotation, Radius, DeltaTime, InterpSpeedMin, InterpSpeedMax); }
	static void InterpBoidArrayToGrid(TArray<FBoid> * InOutBoidArray, const FTransform * WorldTransform, FRotator Rotation, float HorizSize, float VertSize, int NumRows, int NumCols, float DeltaTime, float InterpSpeedMin, float InterpSpeedMax) { NativeCall<void, TArray<FBoid> *, const FTransform *, FRotator, float, float, int, int, float, float, float>(nullptr, "UFlockingBehavior.InterpBoidArrayToGrid", InOutBoidArray, WorldTransform, Rotation, HorizSize, VertSize, NumRows, NumCols, DeltaTime, InterpSpeedMin, InterpSpeedMax); }
	static void InterpBoidArrayToRandom(TArray<FBoid> * InOutBoidArray, const FTransform * WorldTransform, float MinRadius, float MaxRadius, int RandomSeed, float DeltaTime, float InterpSpeedMin, float InterpSpeedMax) { NativeCall<void, TArray<FBoid> *, const FTransform *, float, float, int, float, float, float>(nullptr, "UFlockingBehavior.InterpBoidArrayToRandom", InOutBoidArray, WorldTransform, MinRadius, MaxRadius, RandomSeed, DeltaTime, InterpSpeedMin, InterpSpeedMax); }
	static void InterpBoidArrayToSphere(TArray<FBoid> * InOutBoidArray, const FTransform * WorldTransform, float Radius, int NumRows, TEnumAsByte<enum ESimpleCurve::Type> LatitudeDistribution, float DeltaTime, float InterpSpeedMin, float InterpSpeedMax) { NativeCall<void, TArray<FBoid> *, const FTransform *, float, int, TEnumAsByte<enum ESimpleCurve::Type>, float, float, float>(nullptr, "UFlockingBehavior.InterpBoidArrayToSphere", InOutBoidArray, WorldTransform, Radius, NumRows, LatitudeDistribution, DeltaTime, InterpSpeedMin, InterpSpeedMax); }
	static void InterpVectorArray(TArray<FVector> * InOutVectorArray, const TArray<FVector> * RelativeTargetLocations, FVector Origin, FRotator Rotation, float DeltaTime, float InterpSpeedMin, float InterpSpeedMax) { NativeCall<void, TArray<FVector> *, const TArray<FVector> *, FVector, FRotator, float, float, float>(nullptr, "UFlockingBehavior.InterpVectorArray", InOutVectorArray, RelativeTargetLocations, Origin, Rotation, DeltaTime, InterpSpeedMin, InterpSpeedMax); }
	static void InterpVectorArrayToCircle(TArray<FVector> * InOutVectorArray, FVector Origin, FRotator Rotation, float Radius, float DeltaTime, float InterpSpeedMin, float InterpSpeedMax) { NativeCall<void, TArray<FVector> *, FVector, FRotator, float, float, float, float>(nullptr, "UFlockingBehavior.InterpVectorArrayToCircle", InOutVectorArray, Origin, Rotation, Radius, DeltaTime, InterpSpeedMin, InterpSpeedMax); }
	static void InterpVectorArrayToGrid(TArray<FVector> * InOutVectorArray, FVector Origin, FRotator Rotation, float HorizSize, float VertSize, int NumRows, int NumCols, float DeltaTime, float InterpSpeedMin, float InterpSpeedMax) { NativeCall<void, TArray<FVector> *, FVector, FRotator, float, float, int, int, float, float, float>(nullptr, "UFlockingBehavior.InterpVectorArrayToGrid", InOutVectorArray, Origin, Rotation, HorizSize, VertSize, NumRows, NumCols, DeltaTime, InterpSpeedMin, InterpSpeedMax); }
	static void InterpVectorArrayToRandom(TArray<FVector> * InOutVectorArray, FVector Origin, float MinRadius, float MaxRadius, int RandomSeed, float DeltaTime, float InterpSpeedMin, float InterpSpeedMax) { NativeCall<void, TArray<FVector> *, FVector, float, float, int, float, float, float>(nullptr, "UFlockingBehavior.InterpVectorArrayToRandom", InOutVectorArray, Origin, MinRadius, MaxRadius, RandomSeed, DeltaTime, InterpSpeedMin, InterpSpeedMax); }
	static void InterpVectorArrayToSphere(TArray<FVector> * InOutVectorArray, FVector Origin, float Radius, int NumRows, TEnumAsByte<enum ESimpleCurve::Type> LatitudeDistribution, float DeltaTime, float InterpSpeedMin, float InterpSpeedMax) { NativeCall<void, TArray<FVector> *, FVector, float, int, TEnumAsByte<enum ESimpleCurve::Type>, float, float, float>(nullptr, "UFlockingBehavior.InterpVectorArrayToSphere", InOutVectorArray, Origin, Radius, NumRows, LatitudeDistribution, DeltaTime, InterpSpeedMin, InterpSpeedMax); }
	static bool IsPointInsideAnyAvoidanceArea(const TArray<FAvoidanceArea> * Areas, FVector WorldLocation) { return NativeCall<bool, const TArray<FAvoidanceArea> *, FVector>(nullptr, "UFlockingBehavior.IsPointInsideAnyAvoidanceArea", Areas, WorldLocation); }
	static bool IsPointInsideAvoidanceArea(const FAvoidanceArea * Area, FVector WorldLocation) { return NativeCall<bool, const FAvoidanceArea *, FVector>(nullptr, "UFlockingBehavior.IsPointInsideAvoidanceArea", Area, WorldLocation); }
	static void MakeIndexArray(int StartIndex, int NumIndices, TArray<int> * OutIndexArray) { NativeCall<void, int, int, TArray<int> *>(nullptr, "UFlockingBehavior.MakeIndexArray", StartIndex, NumIndices, OutIndexArray); }
	static void SetAvoidanceAreaArrayTransform(TArray<FAvoidanceArea> * InOutAvoidanceAreas, FTransform NewTransform) { NativeCall<void, TArray<FAvoidanceArea> *, FTransform>(nullptr, "UFlockingBehavior.SetAvoidanceAreaArrayTransform", InOutAvoidanceAreas, NewTransform); }
	static void SetAvoidanceAreaTransform(FAvoidanceArea * InOutAvoidanceArea, FTransform NewTransform) { NativeCall<void, FAvoidanceArea *, FTransform>(nullptr, "UFlockingBehavior.SetAvoidanceAreaTransform", InOutAvoidanceArea, NewTransform); }
	static void TickPersistentFlockData(UObject * WorldContextObject, FFlockPersistentData * InOutFlockData, const TArray<FBoid> * Boids, float DeltaTime, int MaxNumTracesPerSecond, bool bDrawDebug) { NativeCall<void, UObject *, FFlockPersistentData *, const TArray<FBoid> *, float, int, bool>(nullptr, "UFlockingBehavior.TickPersistentFlockData", WorldContextObject, InOutFlockData, Boids, DeltaTime, MaxNumTracesPerSecond, bDrawDebug); }
	static void UpdateBoidComponentLocation(const FBoid * Boid, USceneComponent * Comp) { NativeCall<void, const FBoid *, USceneComponent *>(nullptr, "UFlockingBehavior.UpdateBoidComponentLocation", Boid, Comp); }
	static void UpdateFlockComponentLocations_ParticleBoids(const TArray<FBoid> * BoidArray, const TArray<UParticleSystemComponent *> * ComponentArray) { NativeCall<void, const TArray<FBoid> *, const TArray<UParticleSystemComponent *> *>(nullptr, "UFlockingBehavior.UpdateFlockComponentLocations_ParticleBoids", BoidArray, ComponentArray); }
};

