#pragma once

#include "BaseDeclarations.h"
#include "UBlueprintFunctionLibrary.h"
#include "UObject.h"
#include "UObjectBaseUtility.h"
#include "UObjectBase.h"
#include "UDamageType.h"
#include "AActor.h"
#include "UInterface.h"
#include "FLatentActionInfo.h"
#include "UCameraShake.h"

struct UGameplayStatics : UBlueprintFunctionLibrary
{

	// Functions

	static void ActivateReverbEffect(UReverbEffect * ReverbEffect, FName TagName, float Priority, float Volume, float FadeTime) { NativeCall<void, UReverbEffect *, FName, float, float, float>(nullptr, "UGameplayStatics.ActivateReverbEffect", ReverbEffect, TagName, Priority, Volume, FadeTime); }
	static void ApplyDamage(AActor * DamagedActor, float BaseDamage, AController * EventInstigator, AActor * DamageCauser, TSubclassOf<UDamageType> DamageTypeClass, float Impulse) { NativeCall<void, AActor *, float, AController *, AActor *, TSubclassOf<UDamageType>, float>(nullptr, "UGameplayStatics.ApplyDamage", DamagedActor, BaseDamage, EventInstigator, DamageCauser, DamageTypeClass, Impulse); }
	static void ApplyPointDamage(AActor * DamagedActor, float BaseDamage, const FVector * HitFromDirection, const FHitResult * HitInfo, AController * EventInstigator, AActor * DamageCauser, TSubclassOf<UDamageType> DamageTypeClass, float Impulse, bool bForceCollisionCheck, ECollisionChannel ForceCollisionCheckTraceChannel) { NativeCall<void, AActor *, float, const FVector *, const FHitResult *, AController *, AActor *, TSubclassOf<UDamageType>, float, bool, ECollisionChannel>(nullptr, "UGameplayStatics.ApplyPointDamage", DamagedActor, BaseDamage, HitFromDirection, HitInfo, EventInstigator, DamageCauser, DamageTypeClass, Impulse, bForceCollisionCheck, ForceCollisionCheckTraceChannel); }
	static bool ApplyRadialDamage(UObject * WorldContextObject, float BaseDamage, const FVector * Origin, float DamageRadius, TSubclassOf<UDamageType> DamageTypeClass, const TArray<AActor *> * IgnoreActors, AActor * DamageCauser, AController * InstigatedByController, bool bDoFullDamage, ECollisionChannel DamagePreventionChannel, float Impulse) { return NativeCall<bool, UObject *, float, const FVector *, float, TSubclassOf<UDamageType>, const TArray<AActor *> *, AActor *, AController *, bool, ECollisionChannel, float>(nullptr, "UGameplayStatics.ApplyRadialDamage", WorldContextObject, BaseDamage, Origin, DamageRadius, DamageTypeClass, IgnoreActors, DamageCauser, InstigatedByController, bDoFullDamage, DamagePreventionChannel, Impulse); }
	static bool ApplyRadialDamageIgnoreDamageActors(UObject * WorldContextObject, float BaseDamage, const FVector * Origin, float DamageRadius, TSubclassOf<UDamageType> DamageTypeClass, const TArray<AActor *> * IgnoreActors, const TArray<AActor *> * IgnoreDamageActors, AActor * DamageCauser, AController * InstigatedByController, bool bDoFullDamage, ECollisionChannel DamagePreventionChannel, float Impulse) { return NativeCall<bool, UObject *, float, const FVector *, float, TSubclassOf<UDamageType>, const TArray<AActor *> *, const TArray<AActor *> *, AActor *, AController *, bool, ECollisionChannel, float>(nullptr, "UGameplayStatics.ApplyRadialDamageIgnoreDamageActors", WorldContextObject, BaseDamage, Origin, DamageRadius, DamageTypeClass, IgnoreActors, IgnoreDamageActors, DamageCauser, InstigatedByController, bDoFullDamage, DamagePreventionChannel, Impulse); }
	static bool ApplyRadialDamageWithFalloff(UObject * WorldContextObject, float BaseDamage, float MinimumDamage, const FVector * Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, TSubclassOf<UDamageType> DamageTypeClass, const TArray<AActor *> * IgnoreActors, AActor * DamageCauser, AController * InstigatedByController, ECollisionChannel DamagePreventionChannel, float Impulse, TArray<AActor *> * IgnoreDamageActors, int NumAdditionalAttempts) { return NativeCall<bool, UObject *, float, float, const FVector *, float, float, float, TSubclassOf<UDamageType>, const TArray<AActor *> *, AActor *, AController *, ECollisionChannel, float, TArray<AActor *> *, int>(nullptr, "UGameplayStatics.ApplyRadialDamageWithFalloff", WorldContextObject, BaseDamage, MinimumDamage, Origin, DamageInnerRadius, DamageOuterRadius, DamageFalloff, DamageTypeClass, IgnoreActors, DamageCauser, InstigatedByController, DamagePreventionChannel, Impulse, IgnoreDamageActors, NumAdditionalAttempts); }
	static bool AreAnyListenersWithinRange(FVector Location, float MaximumRange) { return NativeCall<bool, FVector, float>(nullptr, "UGameplayStatics.AreAnyListenersWithinRange", Location, MaximumRange); }
	static float BPPointPlaneDist(const FVector * Point, const FVector * PlaneBase, const FVector * PlaneNorm) { return NativeCall<float, const FVector *, const FVector *, const FVector *>(nullptr, "UGameplayStatics.BPPointPlaneDist", Point, PlaneBase, PlaneNorm); }
	static FVector * BPPointPlaneProject(FVector * result, const FVector * Point, const FVector * PlaneBase, const FVector * PlaneNorm) { return NativeCall<FVector *, FVector *, const FVector *, const FVector *, const FVector *>(nullptr, "UGameplayStatics.BPPointPlaneProject", result, Point, PlaneBase, PlaneNorm); }
	static bool BlueprintSuggestProjectileVelocity(UObject * WorldContextObject, FVector * OutTossVelocity, FVector StartLocation, FVector EndLocation, float LaunchSpeed, float OverrideGravityZ, ESuggestProjVelocityTraceOption::Type TraceOption, float CollisionRadius, bool bFavorHighArc, bool bDrawDebug) { return NativeCall<bool, UObject *, FVector *, FVector, FVector, float, float, ESuggestProjVelocityTraceOption::Type, float, bool, bool>(nullptr, "UGameplayStatics.BlueprintSuggestProjectileVelocity", WorldContextObject, OutTossVelocity, StartLocation, EndLocation, LaunchSpeed, OverrideGravityZ, TraceOption, CollisionRadius, bFavorHighArc, bDrawDebug); }
	static void BreakHitResult(const FHitResult * Hit, FVector * Location, FVector * Normal, FVector * ImpactPoint, FVector * ImpactNormal, UPhysicalMaterial ** PhysMat, AActor ** HitActor, UPrimitiveComponent ** HitComponent, FName * HitBoneName, int * HitItem, bool * BlockingHit) { NativeCall<void, const FHitResult *, FVector *, FVector *, FVector *, FVector *, UPhysicalMaterial **, AActor **, UPrimitiveComponent **, FName *, int *, bool *>(nullptr, "UGameplayStatics.BreakHitResult", Hit, Location, Normal, ImpactPoint, ImpactNormal, PhysMat, HitActor, HitComponent, HitBoneName, HitItem, BlockingHit); }
	static void BreakHitResult_OLD(const FHitResult * Hit, FVector * Location, FVector * Normal, FVector * ImpactPoint, FVector * ImpactNormal, UPhysicalMaterial ** PhysMat, AActor ** HitActor, UPrimitiveComponent ** HitComponent, FName * HitBoneName, int * HitItem) { NativeCall<void, const FHitResult *, FVector *, FVector *, FVector *, FVector *, UPhysicalMaterial **, AActor **, UPrimitiveComponent **, FName *, int *>(nullptr, "UGameplayStatics.BreakHitResult_OLD", Hit, Location, Normal, ImpactPoint, ImpactNormal, PhysMat, HitActor, HitComponent, HitBoneName, HitItem); }
	static void DeactivateReverbEffect(FName TagName) { NativeCall<void, FName>(nullptr, "UGameplayStatics.DeactivateReverbEffect", TagName); }
	static bool DeleteGameInSlot(const FString * SlotName, const int UserIndex) { return NativeCall<bool, const FString *, const int>(nullptr, "UGameplayStatics.DeleteGameInSlot", SlotName, UserIndex); }
	static bool DoesSaveGameExist(const FString * SlotName, const int UserIndex) { return NativeCall<bool, const FString *, const int>(nullptr, "UGameplayStatics.DoesSaveGameExist", SlotName, UserIndex); }
	static void EnableLiveStreaming(bool Enable) { NativeCall<void, bool>(nullptr, "UGameplayStatics.EnableLiveStreaming", Enable); }
	static void GetAccurateRealTime(UObject * WorldContextObject, int * Seconds, float * PartialSeconds) { NativeCall<void, UObject *, int *, float *>(nullptr, "UGameplayStatics.GetAccurateRealTime", WorldContextObject, Seconds, PartialSeconds); }
	static FVector * GetActorArrayAverageLocation(FVector * result, const TArray<AActor *> * Actors) { return NativeCall<FVector *, FVector *, const TArray<AActor *> *>(nullptr, "UGameplayStatics.GetActorArrayAverageLocation", result, Actors); }
	static void GetActorArrayBounds(const TArray<AActor *> * Actors, bool bOnlyCollidingComponents, FVector * Center, FVector * BoxExtent) { NativeCall<void, const TArray<AActor *> *, bool, FVector *, FVector *>(nullptr, "UGameplayStatics.GetActorArrayBounds", Actors, bOnlyCollidingComponents, Center, BoxExtent); }
	static void GetAllActorsOfClass(UObject * WorldContextObject, TSubclassOf<AActor> ActorClass, TArray<AActor *> * OutActors) { NativeCall<void, UObject *, TSubclassOf<AActor>, TArray<AActor *> *>(nullptr, "UGameplayStatics.GetAllActorsOfClass", WorldContextObject, ActorClass, OutActors); }
	static void GetAllActorsWithInterface(UObject * WorldContextObject, TSubclassOf<UInterface> Interface, TArray<AActor *> * OutActors) { NativeCall<void, UObject *, TSubclassOf<UInterface>, TArray<AActor *> *>(nullptr, "UGameplayStatics.GetAllActorsWithInterface", WorldContextObject, Interface, OutActors); }
	static float GetAudioTimeSeconds(UObject * WorldContextObject) { return NativeCall<float, UObject *>(nullptr, "UGameplayStatics.GetAudioTimeSeconds", WorldContextObject); }
	static float GetGlobalTimeDilation(UObject * WorldContextObject) { return NativeCall<float, UObject *>(nullptr, "UGameplayStatics.GetGlobalTimeDilation", WorldContextObject); }
	static FString * GetPlatformName(FString * result) { return NativeCall<FString *, FString *>(nullptr, "UGameplayStatics.GetPlatformName", result); }
	static float GetRealTimeSeconds(UObject * WorldContextObject) { return NativeCall<float, UObject *>(nullptr, "UGameplayStatics.GetRealTimeSeconds", WorldContextObject); }
	static EPhysicalSurface GetSurfaceType(const FHitResult * Hit) { return NativeCall<EPhysicalSurface, const FHitResult *>(nullptr, "UGameplayStatics.GetSurfaceType", Hit); }
	static float GetWorldDeltaSeconds(UObject * WorldContextObject) { return NativeCall<float, UObject *>(nullptr, "UGameplayStatics.GetWorldDeltaSeconds", WorldContextObject); }
	static FIntVector * GetWorldOriginLocation(FIntVector * result, UObject * WorldContextObject) { return NativeCall<FIntVector *, FIntVector *, UObject *>(nullptr, "UGameplayStatics.GetWorldOriginLocation", result, WorldContextObject); }
	static int IsChildOfClasses(TSubclassOf<UObject> childClass, const TArray<TSubclassOf<UObject>> * ParentClassesArray) { return NativeCall<int, TSubclassOf<UObject>, const TArray<TSubclassOf<UObject>> *>(nullptr, "UGameplayStatics.IsChildOfClasses", childClass, ParentClassesArray); }
	static bool IsGamePaused(UObject * WorldContextObject) { return NativeCall<bool, UObject *>(nullptr, "UGameplayStatics.IsGamePaused", WorldContextObject); }
	static bool IsGameWorld(UObject * WorldContextObject) { return NativeCall<bool, UObject *>(nullptr, "UGameplayStatics.IsGameWorld", WorldContextObject); }
	static void LoadStreamLevel(UObject * WorldContextObject, FName LevelName, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, FLatentActionInfo LatentInfo) { NativeCall<void, UObject *, FName, bool, bool, FLatentActionInfo>(nullptr, "UGameplayStatics.LoadStreamLevel", WorldContextObject, LevelName, bMakeVisibleAfterLoad, bShouldBlockOnLoad, LatentInfo); }
	static void OpenLevel(UObject * WorldContextObject, FName LevelName, bool bAbsolute, FString Options) { NativeCall<void, UObject *, FName, bool, FString>(nullptr, "UGameplayStatics.OpenLevel", WorldContextObject, LevelName, bAbsolute, Options); }
	static void PlayDialogueAtLocation(UObject * WorldContextObject, UDialogueWave * Dialogue, const FDialogueContext * Context, FVector Location, float VolumeMultiplier, float PitchMultiplier, float StartTime, USoundAttenuation * AttenuationSettings) { NativeCall<void, UObject *, UDialogueWave *, const FDialogueContext *, FVector, float, float, float, USoundAttenuation *>(nullptr, "UGameplayStatics.PlayDialogueAtLocation", WorldContextObject, Dialogue, Context, Location, VolumeMultiplier, PitchMultiplier, StartTime, AttenuationSettings); }
	static UAudioComponent * PlayDialogueAttached(UDialogueWave * Dialogue, const FDialogueContext * Context, USceneComponent * AttachToComponent, FName AttachPointName, FVector Location, EAttachLocation::Type LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, USoundAttenuation * AttenuationSettings) { return NativeCall<UAudioComponent *, UDialogueWave *, const FDialogueContext *, USceneComponent *, FName, FVector, EAttachLocation::Type, bool, float, float, float, USoundAttenuation *>(nullptr, "UGameplayStatics.PlayDialogueAttached", Dialogue, Context, AttachToComponent, AttachPointName, Location, LocationType, bStopWhenAttachedToDestroyed, VolumeMultiplier, PitchMultiplier, StartTime, AttenuationSettings); }
	static void PlaySound(UObject * WorldContextObject, USoundCue * InSoundCue, USceneComponent * AttachComponent, FName AttachName, bool bFollow, float VolumeMultiplier, float PitchMultiplier) { NativeCall<void, UObject *, USoundCue *, USceneComponent *, FName, bool, float, float>(nullptr, "UGameplayStatics.PlaySound", WorldContextObject, InSoundCue, AttachComponent, AttachName, bFollow, VolumeMultiplier, PitchMultiplier); }
	static void PlaySoundAtLocation(UObject * WorldContextObject, USoundBase * Sound, FVector Location, float VolumeMultiplier, float PitchMultiplier, float StartTime, USoundAttenuation * AttenuationSettings, bool bAlwaysPlay) { NativeCall<void, UObject *, USoundBase *, FVector, float, float, float, USoundAttenuation *, bool>(nullptr, "UGameplayStatics.PlaySoundAtLocation", WorldContextObject, Sound, Location, VolumeMultiplier, PitchMultiplier, StartTime, AttenuationSettings, bAlwaysPlay); }
	static UAudioComponent * PlaySoundAttached(USoundBase * Sound, USceneComponent * AttachToComponent, FName AttachPointName, FVector Location, EAttachLocation::Type LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, USoundAttenuation * AttenuationSettings, bool bAlwaysPlay) { return NativeCall<UAudioComponent *, USoundBase *, USceneComponent *, FName, FVector, EAttachLocation::Type, bool, float, float, float, USoundAttenuation *, bool>(nullptr, "UGameplayStatics.PlaySoundAttached", Sound, AttachToComponent, AttachPointName, Location, LocationType, bStopWhenAttachedToDestroyed, VolumeMultiplier, PitchMultiplier, StartTime, AttenuationSettings, bAlwaysPlay); }
	static void PlayWorldCameraShake(UObject * WorldContextObject, TSubclassOf<UCameraShake> Shake, FVector Epicenter, float InnerRadius, float OuterRadius, float Falloff, bool bOrientShakeTowardsEpicenter, float ScaleMultiplier) { NativeCall<void, UObject *, TSubclassOf<UCameraShake>, FVector, float, float, float, bool, float>(nullptr, "UGameplayStatics.PlayWorldCameraShake", WorldContextObject, Shake, Epicenter, InnerRadius, OuterRadius, Falloff, bOrientShakeTowardsEpicenter, ScaleMultiplier); }
	static void PopSoundMixModifier(USoundMix * InSoundMixModifier) { NativeCall<void, USoundMix *>(nullptr, "UGameplayStatics.PopSoundMixModifier", InSoundMixModifier); }
	static void PushSoundMixModifier(USoundMix * InSoundMixModifier) { NativeCall<void, USoundMix *>(nullptr, "UGameplayStatics.PushSoundMixModifier", InSoundMixModifier); }
	static bool SaveGameToSlot(USaveGame * SaveGameObject, const FString * SlotName, const int UserIndex) { return NativeCall<bool, USaveGame *, const FString *, const int>(nullptr, "UGameplayStatics.SaveGameToSlot", SaveGameObject, SlotName, UserIndex); }
	static void SetBaseSoundMix(USoundMix * InSoundMix) { NativeCall<void, USoundMix *>(nullptr, "UGameplayStatics.SetBaseSoundMix", InSoundMix); }
	static bool SetGamePaused(UObject * WorldContextObject, bool bPaused) { return NativeCall<bool, UObject *, bool>(nullptr, "UGameplayStatics.SetGamePaused", WorldContextObject, bPaused); }
	static void SetGlobalTimeDilation(UObject * WorldContextObject, float TimeDilation) { NativeCall<void, UObject *, float>(nullptr, "UGameplayStatics.SetGlobalTimeDilation", WorldContextObject, TimeDilation); }
	static void SetWorldOriginLocation(UObject * WorldContextObject, FIntVector NewLocation) { NativeCall<void, UObject *, FIntVector>(nullptr, "UGameplayStatics.SetWorldOriginLocation", WorldContextObject, NewLocation); }
	static UDecalComponent * SpawnDecalAtLocation(UObject * WorldContextObject, UMaterialInterface * DecalMaterial, FVector DecalSize, FVector Location, FRotator Rotation, float LifeSpan) { return NativeCall<UDecalComponent *, UObject *, UMaterialInterface *, FVector, FVector, FRotator, float>(nullptr, "UGameplayStatics.SpawnDecalAtLocation", WorldContextObject, DecalMaterial, DecalSize, Location, Rotation, LifeSpan); }
	static UDecalComponent * SpawnDecalAttached(UMaterialInterface * DecalMaterial, FVector DecalSize, USceneComponent * AttachToComponent, FName AttachPointName, FVector Location, FRotator Rotation, EAttachLocation::Type LocationType, float LifeSpan) { return NativeCall<UDecalComponent *, UMaterialInterface *, FVector, USceneComponent *, FName, FVector, FRotator, EAttachLocation::Type, float>(nullptr, "UGameplayStatics.SpawnDecalAttached", DecalMaterial, DecalSize, AttachToComponent, AttachPointName, Location, Rotation, LocationType, LifeSpan); }
	static bool SuggestProjectileVelocity(UObject * WorldContextObject, FVector * OutTossVelocity, FVector Start, FVector End, float TossSpeed, bool bFavorHighArc, float CollisionRadius, float OverrideGravityZ, ESuggestProjVelocityTraceOption::Type TraceOption, const FCollisionResponseParams * ResponseParam, const TArray<AActor *> * ActorsToIgnore, bool bDrawDebug) { return NativeCall<bool, UObject *, FVector *, FVector, FVector, float, bool, float, float, ESuggestProjVelocityTraceOption::Type, const FCollisionResponseParams *, const TArray<AActor *> *, bool>(nullptr, "UGameplayStatics.SuggestProjectileVelocity", WorldContextObject, OutTossVelocity, Start, End, TossSpeed, bFavorHighArc, CollisionRadius, OverrideGravityZ, TraceOption, ResponseParam, ActorsToIgnore, bDrawDebug); }
	static void UnloadStreamLevel(UObject * WorldContextObject, FName LevelName, FLatentActionInfo LatentInfo) { NativeCall<void, UObject *, FName, FLatentActionInfo>(nullptr, "UGameplayStatics.UnloadStreamLevel", WorldContextObject, LevelName, LatentInfo); }
};

