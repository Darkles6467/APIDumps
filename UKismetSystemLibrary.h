#pragma once

#include "BaseDeclarations.h"
#include "UBlueprintFunctionLibrary.h"
#include "UObject.h"
#include "UObjectBaseUtility.h"
#include "UObjectBase.h"
#include "FHitResult.h"
#include "FLatentActionInfo.h"
#include "UInterface.h"

struct UKismetSystemLibrary : UBlueprintFunctionLibrary
{

	// Functions

	static unsigned int MakeLiteralInt(const FName N) { return NativeCall<unsigned int, const FName>(nullptr, "UKismetSystemLibrary.MakeLiteralInt", N); }
	static bool MakeLiteralByte(bool b) { return NativeCall<bool, bool>(nullptr, "UKismetSystemLibrary.MakeLiteralByte", b); }
	unsigned __int64 Conv_InterfaceToObject() { return NativeCall<unsigned __int64>(this, "UKismetSystemLibrary.Conv_InterfaceToObject"); }
	static FString * MakeLiteralString(FString * result, const char * MemoryBlock) { return NativeCall<FString *, FString *, const char *>(nullptr, "UKismetSystemLibrary.MakeLiteralString", result, MemoryBlock); }
	static FDebugFloatHistory * AddFloatHistorySample(FDebugFloatHistory * result, float Value, const FDebugFloatHistory * FloatHistory) { return NativeCall<FDebugFloatHistory *, FDebugFloatHistory *, float, const FDebugFloatHistory *>(nullptr, "UKismetSystemLibrary.AddFloatHistorySample", result, Value, FloatHistory); }
	static bool BoxOverlapActors_DEPRECATED(UObject * WorldContextObject, const FVector BoxPos, FVector BoxExtent, EOverlapFilterOption Filter, UClass * ActorClassFilter, const TArray<AActor *> * ActorsToIgnore, TArray<AActor *> * OutActors) { return NativeCall<bool, UObject *, const FVector, FVector, EOverlapFilterOption, UClass *, const TArray<AActor *> *, TArray<AActor *> *>(nullptr, "UKismetSystemLibrary.BoxOverlapActors_DEPRECATED", WorldContextObject, BoxPos, BoxExtent, Filter, ActorClassFilter, ActorsToIgnore, OutActors); }
	static bool BoxOverlapActors_NEW(UObject * WorldContextObject, const FVector BoxPos, FVector BoxExtent, const TArray<TEnumAsByte<enum EObjectTypeQuery>> * ObjectTypes, UClass * ActorClassFilter, const TArray<AActor *> * ActorsToIgnore, TArray<AActor *> * OutActors) { return NativeCall<bool, UObject *, const FVector, FVector, const TArray<TEnumAsByte<enum EObjectTypeQuery>> *, UClass *, const TArray<AActor *> *, TArray<AActor *> *>(nullptr, "UKismetSystemLibrary.BoxOverlapActors_NEW", WorldContextObject, BoxPos, BoxExtent, ObjectTypes, ActorClassFilter, ActorsToIgnore, OutActors); }
	static bool BoxOverlapComponents_DEPRECATED(UObject * WorldContextObject, const FVector BoxPos, FVector BoxExtent, EOverlapFilterOption Filter, UClass * ComponentClassFilter, const TArray<AActor *> * ActorsToIgnore, TArray<UPrimitiveComponent *> * OutComponents) { return NativeCall<bool, UObject *, const FVector, FVector, EOverlapFilterOption, UClass *, const TArray<AActor *> *, TArray<UPrimitiveComponent *> *>(nullptr, "UKismetSystemLibrary.BoxOverlapComponents_DEPRECATED", WorldContextObject, BoxPos, BoxExtent, Filter, ComponentClassFilter, ActorsToIgnore, OutComponents); }
	static bool BoxOverlapComponents_NEW(UObject * WorldContextObject, const FVector BoxPos, FVector BoxExtent, const TArray<TEnumAsByte<enum EObjectTypeQuery>> * ObjectTypes, UClass * ComponentClassFilter, const TArray<AActor *> * ActorsToIgnore, TArray<UPrimitiveComponent *> * OutComponents) { return NativeCall<bool, UObject *, const FVector, FVector, const TArray<TEnumAsByte<enum EObjectTypeQuery>> *, UClass *, const TArray<AActor *> *, TArray<UPrimitiveComponent *> *>(nullptr, "UKismetSystemLibrary.BoxOverlapComponents_NEW", WorldContextObject, BoxPos, BoxExtent, ObjectTypes, ComponentClassFilter, ActorsToIgnore, OutComponents); }
	static bool BoxTraceMulti(UObject * WorldContextObject, const FVector Start, const FVector End, FVector HalfSize, const FRotator Orientation, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, TArray<FHitResult> * OutHits, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, FVector, const FRotator, ETraceTypeQuery, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, TArray<FHitResult> *, bool>(nullptr, "UKismetSystemLibrary.BoxTraceMulti", WorldContextObject, Start, End, HalfSize, Orientation, TraceChannel, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHits, bIgnoreSelf); }
	static bool BoxTraceMultiForObjects(UObject * WorldContextObject, const FVector Start, const FVector End, const FVector HalfSize, const FRotator Orientation, const TArray<TEnumAsByte<enum EObjectTypeQuery>> * ObjectTypes, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, TArray<FHitResult> * OutHits, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, const FVector, const FRotator, const TArray<TEnumAsByte<enum EObjectTypeQuery>> *, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, TArray<FHitResult> *, bool>(nullptr, "UKismetSystemLibrary.BoxTraceMultiForObjects", WorldContextObject, Start, End, HalfSize, Orientation, ObjectTypes, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHits, bIgnoreSelf); }
	static bool BoxTraceSingle(UObject * WorldContextObject, const FVector Start, const FVector End, const FVector HalfSize, const FRotator Orientation, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, FHitResult * OutHit, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, const FVector, const FRotator, ETraceTypeQuery, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, FHitResult *, bool>(nullptr, "UKismetSystemLibrary.BoxTraceSingle", WorldContextObject, Start, End, HalfSize, Orientation, TraceChannel, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHit, bIgnoreSelf); }
	static bool BoxTraceSingleForObjects(UObject * WorldContextObject, const FVector Start, const FVector End, const FVector HalfSize, const FRotator Orientation, const TArray<TEnumAsByte<enum EObjectTypeQuery>> * ObjectTypes, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, FHitResult * OutHit, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, const FVector, const FRotator, const TArray<TEnumAsByte<enum EObjectTypeQuery>> *, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, FHitResult *, bool>(nullptr, "UKismetSystemLibrary.BoxTraceSingleForObjects", WorldContextObject, Start, End, HalfSize, Orientation, ObjectTypes, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHit, bIgnoreSelf); }
	static void CanRunCosmeticEvents(UObject * WorldContextObject, TEnumAsByte<enum ENetworkModeResult::Type> * OutNetworkMode) { NativeCall<void, UObject *, TEnumAsByte<enum ENetworkModeResult::Type> *>(nullptr, "UKismetSystemLibrary.CanRunCosmeticEvents", WorldContextObject, OutNetworkMode); }
	static bool CapsuleOverlapActors_DEPRECATED(UObject * WorldContextObject, const FVector CapsulePos, float Radius, float HalfHeight, EOverlapFilterOption Filter, UClass * ActorClassFilter, const TArray<AActor *> * ActorsToIgnore, TArray<AActor *> * OutActors) { return NativeCall<bool, UObject *, const FVector, float, float, EOverlapFilterOption, UClass *, const TArray<AActor *> *, TArray<AActor *> *>(nullptr, "UKismetSystemLibrary.CapsuleOverlapActors_DEPRECATED", WorldContextObject, CapsulePos, Radius, HalfHeight, Filter, ActorClassFilter, ActorsToIgnore, OutActors); }
	static bool CapsuleOverlapActors_NEW(UObject * WorldContextObject, const FVector CapsulePos, float Radius, float HalfHeight, const TArray<TEnumAsByte<enum EObjectTypeQuery>> * ObjectTypes, UClass * ActorClassFilter, const TArray<AActor *> * ActorsToIgnore, TArray<AActor *> * OutActors) { return NativeCall<bool, UObject *, const FVector, float, float, const TArray<TEnumAsByte<enum EObjectTypeQuery>> *, UClass *, const TArray<AActor *> *, TArray<AActor *> *>(nullptr, "UKismetSystemLibrary.CapsuleOverlapActors_NEW", WorldContextObject, CapsulePos, Radius, HalfHeight, ObjectTypes, ActorClassFilter, ActorsToIgnore, OutActors); }
	static bool CapsuleOverlapComponents_DEPRECATED(UObject * WorldContextObject, const FVector CapsulePos, float Radius, float HalfHeight, EOverlapFilterOption Filter, UClass * ComponentClassFilter, const TArray<AActor *> * ActorsToIgnore, TArray<UPrimitiveComponent *> * OutComponents) { return NativeCall<bool, UObject *, const FVector, float, float, EOverlapFilterOption, UClass *, const TArray<AActor *> *, TArray<UPrimitiveComponent *> *>(nullptr, "UKismetSystemLibrary.CapsuleOverlapComponents_DEPRECATED", WorldContextObject, CapsulePos, Radius, HalfHeight, Filter, ComponentClassFilter, ActorsToIgnore, OutComponents); }
	static bool CapsuleOverlapComponents_NEW(UObject * WorldContextObject, const FVector CapsulePos, float Radius, float HalfHeight, const TArray<TEnumAsByte<enum EObjectTypeQuery>> * ObjectTypes, UClass * ComponentClassFilter, const TArray<AActor *> * ActorsToIgnore, TArray<UPrimitiveComponent *> * OutComponents) { return NativeCall<bool, UObject *, const FVector, float, float, const TArray<TEnumAsByte<enum EObjectTypeQuery>> *, UClass *, const TArray<AActor *> *, TArray<UPrimitiveComponent *> *>(nullptr, "UKismetSystemLibrary.CapsuleOverlapComponents_NEW", WorldContextObject, CapsulePos, Radius, HalfHeight, ObjectTypes, ComponentClassFilter, ActorsToIgnore, OutComponents); }
	static bool CapsuleTraceMultiByObject_DEPRECATED(UObject * WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, const TArray<TEnumAsByte<enum ECollisionChannel>> * ObjectsToTrace, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, TArray<FHitResult> * OutHits, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, float, float, const TArray<TEnumAsByte<enum ECollisionChannel>> *, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, TArray<FHitResult> *, bool>(nullptr, "UKismetSystemLibrary.CapsuleTraceMultiByObject_DEPRECATED", WorldContextObject, Start, End, Radius, HalfHeight, ObjectsToTrace, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHits, bIgnoreSelf); }
	static bool CapsuleTraceMultiForObjects(UObject * WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, const TArray<TEnumAsByte<enum EObjectTypeQuery>> * ObjectTypes, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, TArray<FHitResult> * OutHits, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, float, float, const TArray<TEnumAsByte<enum EObjectTypeQuery>> *, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, TArray<FHitResult> *, bool>(nullptr, "UKismetSystemLibrary.CapsuleTraceMultiForObjects", WorldContextObject, Start, End, Radius, HalfHeight, ObjectTypes, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHits, bIgnoreSelf); }
	static bool CapsuleTraceMulti_DEPRECATED(UObject * WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, ECollisionChannel TraceChannel, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, TArray<FHitResult> * OutHits, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, float, float, ECollisionChannel, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, TArray<FHitResult> *, bool>(nullptr, "UKismetSystemLibrary.CapsuleTraceMulti_DEPRECATED", WorldContextObject, Start, End, Radius, HalfHeight, TraceChannel, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHits, bIgnoreSelf); }
	static bool CapsuleTraceMulti_NEW(UObject * WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, TArray<FHitResult> * OutHits, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, float, float, ETraceTypeQuery, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, TArray<FHitResult> *, bool>(nullptr, "UKismetSystemLibrary.CapsuleTraceMulti_NEW", WorldContextObject, Start, End, Radius, HalfHeight, TraceChannel, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHits, bIgnoreSelf); }
	static bool CapsuleTraceSingleByObject_DEPRECATED(UObject * WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, const TArray<TEnumAsByte<enum ECollisionChannel>> * ObjectsToTrace, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, FHitResult * OutHit, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, float, float, const TArray<TEnumAsByte<enum ECollisionChannel>> *, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, FHitResult *, bool>(nullptr, "UKismetSystemLibrary.CapsuleTraceSingleByObject_DEPRECATED", WorldContextObject, Start, End, Radius, HalfHeight, ObjectsToTrace, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHit, bIgnoreSelf); }
	static bool CapsuleTraceSingleForObjects(UObject * WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, const TArray<TEnumAsByte<enum EObjectTypeQuery>> * ObjectTypes, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, FHitResult * OutHit, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, float, float, const TArray<TEnumAsByte<enum EObjectTypeQuery>> *, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, FHitResult *, bool>(nullptr, "UKismetSystemLibrary.CapsuleTraceSingleForObjects", WorldContextObject, Start, End, Radius, HalfHeight, ObjectTypes, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHit, bIgnoreSelf); }
	static bool CapsuleTraceSingle_DEPRECATED(UObject * WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, ECollisionChannel TraceChannel, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, FHitResult * OutHit, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, float, float, ECollisionChannel, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, FHitResult *, bool>(nullptr, "UKismetSystemLibrary.CapsuleTraceSingle_DEPRECATED", WorldContextObject, Start, End, Radius, HalfHeight, TraceChannel, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHit, bIgnoreSelf); }
	static bool CapsuleTraceSingle_NEW(UObject * WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, FHitResult * OutHit, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, float, float, ETraceTypeQuery, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, FHitResult *, bool>(nullptr, "UKismetSystemLibrary.CapsuleTraceSingle_NEW", WorldContextObject, Start, End, Radius, HalfHeight, TraceChannel, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHit, bIgnoreSelf); }
	static bool ComponentOverlapActors_DEPRECATED(UPrimitiveComponent * Component, const FTransform * ComponentTransform, EOverlapFilterOption Filter, UClass * ActorClassFilter, const TArray<AActor *> * ActorsToIgnore, TArray<AActor *> * OutActors) { return NativeCall<bool, UPrimitiveComponent *, const FTransform *, EOverlapFilterOption, UClass *, const TArray<AActor *> *, TArray<AActor *> *>(nullptr, "UKismetSystemLibrary.ComponentOverlapActors_DEPRECATED", Component, ComponentTransform, Filter, ActorClassFilter, ActorsToIgnore, OutActors); }
	static bool ComponentOverlapActors_NEW(UPrimitiveComponent * Component, const FTransform * ComponentTransform, const TArray<TEnumAsByte<enum EObjectTypeQuery>> * ObjectTypes, UClass * ActorClassFilter, const TArray<AActor *> * ActorsToIgnore, TArray<AActor *> * OutActors) { return NativeCall<bool, UPrimitiveComponent *, const FTransform *, const TArray<TEnumAsByte<enum EObjectTypeQuery>> *, UClass *, const TArray<AActor *> *, TArray<AActor *> *>(nullptr, "UKismetSystemLibrary.ComponentOverlapActors_NEW", Component, ComponentTransform, ObjectTypes, ActorClassFilter, ActorsToIgnore, OutActors); }
	static bool ComponentOverlapComponents_DEPRECATED(UPrimitiveComponent * Component, const FTransform * ComponentTransform, EOverlapFilterOption Filter, UClass * ComponentClassFilter, const TArray<AActor *> * ActorsToIgnore, TArray<UPrimitiveComponent *> * OutComponents) { return NativeCall<bool, UPrimitiveComponent *, const FTransform *, EOverlapFilterOption, UClass *, const TArray<AActor *> *, TArray<UPrimitiveComponent *> *>(nullptr, "UKismetSystemLibrary.ComponentOverlapComponents_DEPRECATED", Component, ComponentTransform, Filter, ComponentClassFilter, ActorsToIgnore, OutComponents); }
	static bool ComponentOverlapComponents_NEW(UPrimitiveComponent * Component, const FTransform * ComponentTransform, const TArray<TEnumAsByte<enum EObjectTypeQuery>> * ObjectTypes, UClass * ComponentClassFilter, const TArray<AActor *> * ActorsToIgnore, TArray<UPrimitiveComponent *> * OutComponents) { return NativeCall<bool, UPrimitiveComponent *, const FTransform *, const TArray<TEnumAsByte<enum EObjectTypeQuery>> *, UClass *, const TArray<AActor *> *, TArray<UPrimitiveComponent *> *>(nullptr, "UKismetSystemLibrary.ComponentOverlapComponents_NEW", Component, ComponentTransform, ObjectTypes, ComponentClassFilter, ActorsToIgnore, OutComponents); }
	static void CreateCopyForUndoBuffer(UObject * ObjectToModify) { NativeCall<void, UObject *>(nullptr, "UKismetSystemLibrary.CreateCopyForUndoBuffer", ObjectToModify); }
	static void Delay(UObject * WorldContextObject, float Duration, FLatentActionInfo LatentInfo) { NativeCall<void, UObject *, float, FLatentActionInfo>(nullptr, "UKismetSystemLibrary.Delay", WorldContextObject, Duration, LatentInfo); }
	static bool DoesImplementInterface(UObject * TestObject, TSubclassOf<UInterface> Interface) { return NativeCall<bool, UObject *, TSubclassOf<UInterface>>(nullptr, "UKismetSystemLibrary.DoesImplementInterface", TestObject, Interface); }
	static void DrawDebugArrow(UObject * WorldContextObject, const FVector LineStart, const FVector LineEnd, float ArrowSize, FLinearColor Color, float LifeTime, bool bPersistent) { NativeCall<void, UObject *, const FVector, const FVector, float, FLinearColor, float, bool>(nullptr, "UKismetSystemLibrary.DrawDebugArrow", WorldContextObject, LineStart, LineEnd, ArrowSize, Color, LifeTime, bPersistent); }
	static void DrawDebugBox(UObject * WorldContextObject, const FVector Center, FVector Extent, FLinearColor Color, const FRotator Rotation, float LifeTime, bool bPersistent) { NativeCall<void, UObject *, const FVector, FVector, FLinearColor, const FRotator, float, bool>(nullptr, "UKismetSystemLibrary.DrawDebugBox", WorldContextObject, Center, Extent, Color, Rotation, LifeTime, bPersistent); }
	static void DrawDebugCamera(const ACameraActor * CameraActor, FLinearColor CameraColor, float Duration, bool bPersistent) { NativeCall<void, const ACameraActor *, FLinearColor, float, bool>(nullptr, "UKismetSystemLibrary.DrawDebugCamera", CameraActor, CameraColor, Duration, bPersistent); }
	static void DrawDebugCapsule(UObject * WorldContextObject, const FVector Center, float HalfHeight, float Radius, const FRotator Rotation, FLinearColor Color, float LifeTime, bool bPersistent) { NativeCall<void, UObject *, const FVector, float, float, const FRotator, FLinearColor, float, bool>(nullptr, "UKismetSystemLibrary.DrawDebugCapsule", WorldContextObject, Center, HalfHeight, Radius, Rotation, Color, LifeTime, bPersistent); }
	static void DrawDebugCapsuleWithExtents(UObject * WorldContextObject, const FVector Top, const FVector Bottom, float Radius, FLinearColor Color, float LifeTime, bool bPersistent) { NativeCall<void, UObject *, const FVector, const FVector, float, FLinearColor, float, bool>(nullptr, "UKismetSystemLibrary.DrawDebugCapsuleWithExtents", WorldContextObject, Top, Bottom, Radius, Color, LifeTime, bPersistent); }
	static void DrawDebugCircle(UObject * WorldContextObject, const FVector Center, const FRotator Rotation, float Radius, int Segments, FLinearColor Color, float LifeTime, bool bPersistent) { NativeCall<void, UObject *, const FVector, const FRotator, float, int, FLinearColor, float, bool>(nullptr, "UKismetSystemLibrary.DrawDebugCircle", WorldContextObject, Center, Rotation, Radius, Segments, Color, LifeTime, bPersistent); }
	static void DrawDebugCone(UObject * WorldContextObject, const FVector Origin, const FVector Direction, float Length, float AngleWidth, float AngleHeight, int NumSides, FLinearColor Color, float LifeTime, bool bPersistent) { NativeCall<void, UObject *, const FVector, const FVector, float, float, float, int, FLinearColor, float, bool>(nullptr, "UKismetSystemLibrary.DrawDebugCone", WorldContextObject, Origin, Direction, Length, AngleWidth, AngleHeight, NumSides, Color, LifeTime, bPersistent); }
	static void DrawDebugConeInDegrees(UObject * WorldContextObject, const FVector Origin, const FVector Direction, float Length, float AngleWidth, float AngleHeight, int NumSides, FLinearColor Color, float LifeTime, bool bPersistent) { NativeCall<void, UObject *, const FVector, const FVector, float, float, float, int, FLinearColor, float, bool>(nullptr, "UKismetSystemLibrary.DrawDebugConeInDegrees", WorldContextObject, Origin, Direction, Length, AngleWidth, AngleHeight, NumSides, Color, LifeTime, bPersistent); }
	static void DrawDebugCoordinateSystem(UObject * WorldContextObject, const FVector AxisLoc, const FRotator AxisRot, float Scale, float Thickness, float LifeTime, bool bPersistent) { NativeCall<void, UObject *, const FVector, const FRotator, float, float, float, bool>(nullptr, "UKismetSystemLibrary.DrawDebugCoordinateSystem", WorldContextObject, AxisLoc, AxisRot, Scale, Thickness, LifeTime, bPersistent); }
	static void DrawDebugCylinder(UObject * WorldContextObject, const FVector Start, const FVector End, float Radius, int Segments, FLinearColor Color, float LifeTime, bool bPersistent) { NativeCall<void, UObject *, const FVector, const FVector, float, int, FLinearColor, float, bool>(nullptr, "UKismetSystemLibrary.DrawDebugCylinder", WorldContextObject, Start, End, Radius, Segments, Color, LifeTime, bPersistent); }
	static void DrawDebugFloatHistoryLocation(UObject * WorldContextObject, const FDebugFloatHistory * FloatHistory, FVector DrawLocation, FVector2D DrawSize, FLinearColor DrawColor, float LifeTime, bool bPersistent) { NativeCall<void, UObject *, const FDebugFloatHistory *, FVector, FVector2D, FLinearColor, float, bool>(nullptr, "UKismetSystemLibrary.DrawDebugFloatHistoryLocation", WorldContextObject, FloatHistory, DrawLocation, DrawSize, DrawColor, LifeTime, bPersistent); }
	static void DrawDebugFloatHistoryTransform(UObject * WorldContextObject, const FDebugFloatHistory * FloatHistory, const FTransform * DrawTransform, FVector2D DrawSize, FLinearColor DrawColor, float LifeTime, bool bPersistent) { NativeCall<void, UObject *, const FDebugFloatHistory *, const FTransform *, FVector2D, FLinearColor, float, bool>(nullptr, "UKismetSystemLibrary.DrawDebugFloatHistoryTransform", WorldContextObject, FloatHistory, DrawTransform, DrawSize, DrawColor, LifeTime, bPersistent); }
	static void DrawDebugFrustum(UObject * WorldContextObject, const FTransform * FrustumTransform, FLinearColor FrustumColor, float Duration, bool bPersistent) { NativeCall<void, UObject *, const FTransform *, FLinearColor, float, bool>(nullptr, "UKismetSystemLibrary.DrawDebugFrustum", WorldContextObject, FrustumTransform, FrustumColor, Duration, bPersistent); }
	static void DrawDebugLine(UObject * WorldContextObject, const FVector LineStart, const FVector LineEnd, FLinearColor Color, float LifeTime, float Thickness, bool bPersistent) { NativeCall<void, UObject *, const FVector, const FVector, FLinearColor, float, float, bool>(nullptr, "UKismetSystemLibrary.DrawDebugLine", WorldContextObject, LineStart, LineEnd, Color, LifeTime, Thickness, bPersistent); }
	static void DrawDebugLineTraceHitResult(UObject * WorldContextObject, const FHitResult * Hit, const FVector * TraceStart, const FVector * TraceEnd, FLinearColor StartColor, FLinearColor HitColor, float LineThickness, float HitSize, bool bDrawHitNormal, FLinearColor HitNormalColor, float HitNormalLength, float Duration, bool bPersistent) { NativeCall<void, UObject *, const FHitResult *, const FVector *, const FVector *, FLinearColor, FLinearColor, float, float, bool, FLinearColor, float, float, bool>(nullptr, "UKismetSystemLibrary.DrawDebugLineTraceHitResult", WorldContextObject, Hit, TraceStart, TraceEnd, StartColor, HitColor, LineThickness, HitSize, bDrawHitNormal, HitNormalColor, HitNormalLength, Duration, bPersistent); }
	static void DrawDebugPlane(UObject * WorldContextObject, const FPlane * P, const FVector Loc, float Size, FLinearColor Color, float LifeTime, bool bPersistent) { NativeCall<void, UObject *, const FPlane *, const FVector, float, FLinearColor, float, bool>(nullptr, "UKismetSystemLibrary.DrawDebugPlane", WorldContextObject, P, Loc, Size, Color, LifeTime, bPersistent); }
	static void DrawDebugPoint(UObject * WorldContextObject, const FVector Position, float Size, FLinearColor PointColor, float LifeTime, bool bPersistent) { NativeCall<void, UObject *, const FVector, float, FLinearColor, float, bool>(nullptr, "UKismetSystemLibrary.DrawDebugPoint", WorldContextObject, Position, Size, PointColor, LifeTime, bPersistent); }
	static void DrawDebugSphere(UObject * WorldContextObject, const FVector Center, float Radius, int Segments, FLinearColor Color, float LifeTime, bool bPersistent) { NativeCall<void, UObject *, const FVector, float, int, FLinearColor, float, bool>(nullptr, "UKismetSystemLibrary.DrawDebugSphere", WorldContextObject, Center, Radius, Segments, Color, LifeTime, bPersistent); }
	static void DrawDebugString(UObject * WorldContextObject, const FVector TextLocation, const FString * Text, AActor * TestBaseActor, FLinearColor TextColor, float Duration) { NativeCall<void, UObject *, const FVector, const FString *, AActor *, FLinearColor, float>(nullptr, "UKismetSystemLibrary.DrawDebugString", WorldContextObject, TextLocation, Text, TestBaseActor, TextColor, Duration); }
	static void ExecuteConsoleCommand(UObject * WorldContextObject, const FString * Command, APlayerController * Player) { NativeCall<void, UObject *, const FString *, APlayerController *>(nullptr, "UKismetSystemLibrary.ExecuteConsoleCommand", WorldContextObject, Command, Player); }
	static void FlushDebugStrings(UObject * WorldContextObject) { NativeCall<void, UObject *>(nullptr, "UKismetSystemLibrary.FlushDebugStrings", WorldContextObject); }
	static void FlushPersistentDebugLines(UObject * WorldContextObject) { NativeCall<void, UObject *>(nullptr, "UKismetSystemLibrary.FlushPersistentDebugLines", WorldContextObject); }
	static void Generic_SetStructurePropertyByName(UObject * OwnerObject, FName StructPropertyName, const void * SrcStructAddr) { NativeCall<void, UObject *, FName, const void *>(nullptr, "UKismetSystemLibrary.Generic_SetStructurePropertyByName", OwnerObject, StructPropertyName, SrcStructAddr); }
	static void GetActorBounds(AActor * Actor, FVector * Origin, FVector * BoxExtent) { NativeCall<void, AActor *, FVector *, FVector *>(nullptr, "UKismetSystemLibrary.GetActorBounds", Actor, Origin, BoxExtent); }
	static void GetActorListFromComponentList(const TArray<UPrimitiveComponent *> * ComponentList, UClass * ActorClassFilter, TArray<AActor *> * OutActorList) { NativeCall<void, const TArray<UPrimitiveComponent *> *, UClass *, TArray<AActor *> *>(nullptr, "UKismetSystemLibrary.GetActorListFromComponentList", ComponentList, ActorClassFilter, OutActorList); }
	static FString * GetClassDisplayName(FString * result, UClass * Class) { return NativeCall<FString *, FString *, UClass *>(nullptr, "UKismetSystemLibrary.GetClassDisplayName", result, Class); }
	static void GetComponentBounds(const USceneComponent * Component, FVector * Origin, FVector * BoxExtent, float * SphereRadius) { NativeCall<void, const USceneComponent *, FVector *, FVector *, float *>(nullptr, "UKismetSystemLibrary.GetComponentBounds", Component, Origin, BoxExtent, SphereRadius); }
	static FString * GetDisplayName(FString * result, UObject * Object) { return NativeCall<FString *, FString *, UObject *>(nullptr, "UKismetSystemLibrary.GetDisplayName", result, Object); }
	static FString * GetEngineVersion(FString * result) { return NativeCall<FString *, FString *>(nullptr, "UKismetSystemLibrary.GetEngineVersion", result); }
	static FString * GetGameName(FString * result) { return NativeCall<FString *, FString *>(nullptr, "UKismetSystemLibrary.GetGameName", result); }
	static long double GetGameTimeInSeconds(UObject * WorldContextObject) { return NativeCall<long double, UObject *>(nullptr, "UKismetSystemLibrary.GetGameTimeInSeconds", WorldContextObject); }
	static FString * GetPlatformUserName(FString * result) { return NativeCall<FString *, FString *>(nullptr, "UKismetSystemLibrary.GetPlatformUserName", result); }
	static int GetRenderingDetailMode() { return NativeCall<int>(nullptr, "UKismetSystemLibrary.GetRenderingDetailMode"); }
	static int GetRenderingMaterialQualityLevel() { return NativeCall<int>(nullptr, "UKismetSystemLibrary.GetRenderingMaterialQualityLevel"); }
	static FString * GetUniqueDeviceId(FString * result) { return NativeCall<FString *, FString *>(nullptr, "UKismetSystemLibrary.GetUniqueDeviceId", result); }
	static bool IsClient(UObject * WorldContextObject) { return NativeCall<bool, UObject *>(nullptr, "UKismetSystemLibrary.IsClient", WorldContextObject); }
	static bool IsDedicatedServer(UObject * WorldContextObject) { return NativeCall<bool, UObject *>(nullptr, "UKismetSystemLibrary.IsDedicatedServer", WorldContextObject); }
	static bool IsListenServer(UObject * WorldContextObject) { return NativeCall<bool, UObject *>(nullptr, "UKismetSystemLibrary.IsListenServer", WorldContextObject); }
	static void IsRunningOnServer(UObject * WorldContextObject, TEnumAsByte<enum ENetworkModeResult::Type> * OutNetworkMode) { NativeCall<void, UObject *, TEnumAsByte<enum ENetworkModeResult::Type> *>(nullptr, "UKismetSystemLibrary.IsRunningOnServer", WorldContextObject, OutNetworkMode); }
	static bool IsServer(UObject * WorldContextObject) { return NativeCall<bool, UObject *>(nullptr, "UKismetSystemLibrary.IsServer", WorldContextObject); }
	static bool IsStandalone(UObject * WorldContextObject) { return NativeCall<bool, UObject *>(nullptr, "UKismetSystemLibrary.IsStandalone", WorldContextObject); }
	static bool IsValid(UObject * Object) { return NativeCall<bool, UObject *>(nullptr, "UKismetSystemLibrary.IsValid", Object); }
	static void K2_ClearTimer(UObject * Object, FString FunctionName) { NativeCall<void, UObject *, FString>(nullptr, "UKismetSystemLibrary.K2_ClearTimer", Object, FunctionName); }
	static float K2_GetTimerElapsedTime(UObject * Object, FString FunctionName) { return NativeCall<float, UObject *, FString>(nullptr, "UKismetSystemLibrary.K2_GetTimerElapsedTime", Object, FunctionName); }
	static float K2_GetTimerRemainingTime(UObject * Object, FString FunctionName) { return NativeCall<float, UObject *, FString>(nullptr, "UKismetSystemLibrary.K2_GetTimerRemainingTime", Object, FunctionName); }
	static bool K2_IsTimerActive(UObject * Object, FString FunctionName) { return NativeCall<bool, UObject *, FString>(nullptr, "UKismetSystemLibrary.K2_IsTimerActive", Object, FunctionName); }
	static bool K2_IsTimerPaused(UObject * Object, FString FunctionName) { return NativeCall<bool, UObject *, FString>(nullptr, "UKismetSystemLibrary.K2_IsTimerPaused", Object, FunctionName); }
	static void K2_PauseTimer(UObject * Object, FString FunctionName) { NativeCall<void, UObject *, FString>(nullptr, "UKismetSystemLibrary.K2_PauseTimer", Object, FunctionName); }
	static void K2_SetTimer(UObject * Object, FString FunctionName, float Time, bool bLooping) { NativeCall<void, UObject *, FString, float, bool>(nullptr, "UKismetSystemLibrary.K2_SetTimer", Object, FunctionName, Time, bLooping); }
	static void K2_SetTimerForNextTick(UObject * Object, FString FunctionName, bool bLooping) { NativeCall<void, UObject *, FString, bool>(nullptr, "UKismetSystemLibrary.K2_SetTimerForNextTick", Object, FunctionName, bLooping); }
	static bool K2_TimerExists(UObject * Object, FString FunctionName) { return NativeCall<bool, UObject *, FString>(nullptr, "UKismetSystemLibrary.K2_TimerExists", Object, FunctionName); }
	static void K2_UnPauseTimer(UObject * Object, FString FunctionName) { NativeCall<void, UObject *, FString>(nullptr, "UKismetSystemLibrary.K2_UnPauseTimer", Object, FunctionName); }
	static void LaunchURL(const FString * URL) { NativeCall<void, const FString *>(nullptr, "UKismetSystemLibrary.LaunchURL", URL); }
	static bool LineTraceMultiByObject_DEPRECATED(UObject * WorldContextObject, const FVector Start, const FVector End, const TArray<TEnumAsByte<enum ECollisionChannel>> * ObjectsToTrace, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, TArray<FHitResult> * OutHits, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, const TArray<TEnumAsByte<enum ECollisionChannel>> *, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, TArray<FHitResult> *, bool>(nullptr, "UKismetSystemLibrary.LineTraceMultiByObject_DEPRECATED", WorldContextObject, Start, End, ObjectsToTrace, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHits, bIgnoreSelf); }
	static bool LineTraceMultiForObjects(UObject * WorldContextObject, const FVector Start, const FVector End, const TArray<TEnumAsByte<enum EObjectTypeQuery>> * ObjectTypes, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, TArray<FHitResult> * OutHits, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, const TArray<TEnumAsByte<enum EObjectTypeQuery>> *, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, TArray<FHitResult> *, bool>(nullptr, "UKismetSystemLibrary.LineTraceMultiForObjects", WorldContextObject, Start, End, ObjectTypes, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHits, bIgnoreSelf); }
	static bool LineTraceMulti_DEPRECATED(UObject * WorldContextObject, const FVector Start, const FVector End, ECollisionChannel TraceChannel, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, TArray<FHitResult> * OutHits, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, ECollisionChannel, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, TArray<FHitResult> *, bool>(nullptr, "UKismetSystemLibrary.LineTraceMulti_DEPRECATED", WorldContextObject, Start, End, TraceChannel, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHits, bIgnoreSelf); }
	static bool LineTraceMulti_NEW(UObject * WorldContextObject, const FVector Start, const FVector End, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, TArray<FHitResult> * OutHits, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, ETraceTypeQuery, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, TArray<FHitResult> *, bool>(nullptr, "UKismetSystemLibrary.LineTraceMulti_NEW", WorldContextObject, Start, End, TraceChannel, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHits, bIgnoreSelf); }
	static bool LineTraceSingleByObject_DEPRECATED(UObject * WorldContextObject, const FVector Start, const FVector End, const TArray<TEnumAsByte<enum ECollisionChannel>> * ObjectsToTrace, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, FHitResult * OutHit, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, const TArray<TEnumAsByte<enum ECollisionChannel>> *, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, FHitResult *, bool>(nullptr, "UKismetSystemLibrary.LineTraceSingleByObject_DEPRECATED", WorldContextObject, Start, End, ObjectsToTrace, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHit, bIgnoreSelf); }
	static bool LineTraceSingleForObjects(UObject * WorldContextObject, const FVector Start, const FVector End, const TArray<TEnumAsByte<enum EObjectTypeQuery>> * ObjectTypes, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, FHitResult * OutHit, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, const TArray<TEnumAsByte<enum EObjectTypeQuery>> *, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, FHitResult *, bool>(nullptr, "UKismetSystemLibrary.LineTraceSingleForObjects", WorldContextObject, Start, End, ObjectTypes, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHit, bIgnoreSelf); }
	static bool LineTraceSingle_DEPRECATED(UObject * WorldContextObject, const FVector Start, const FVector End, ECollisionChannel TraceChannel, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, FHitResult * OutHit, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, ECollisionChannel, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, FHitResult *, bool>(nullptr, "UKismetSystemLibrary.LineTraceSingle_DEPRECATED", WorldContextObject, Start, End, TraceChannel, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHit, bIgnoreSelf); }
	static bool LineTraceSingle_NEW(UObject * WorldContextObject, const FVector Start, const FVector End, ECollisionChannel TraceChannel, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, FHitResult * OutHit, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, ECollisionChannel, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, FHitResult *, bool>(nullptr, "UKismetSystemLibrary.LineTraceSingle_NEW", WorldContextObject, Start, End, TraceChannel, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHit, bIgnoreSelf); }
	void MakeLiteralName(UObject * InObject) { NativeCall<void, UObject *>(this, "UKismetSystemLibrary.MakeLiteralName", InObject); }
	static FText * MakeLiteralText(FText * result, FText Value) { return NativeCall<FText *, FText *, FText>(nullptr, "UKismetSystemLibrary.MakeLiteralText", result, Value); }
	static void MoveComponentTo(USceneComponent * Component, FVector TargetRelativeLocation, FRotator TargetRelativeRotation, bool bEaseOut, bool bEaseIn, float OverTime, TEnumAsByte<enum EMoveComponentAction::Type> MoveAction, FLatentActionInfo LatentInfo, bool bSweep) { NativeCall<void, USceneComponent *, FVector, FRotator, bool, bool, float, TEnumAsByte<enum EMoveComponentAction::Type>, FLatentActionInfo, bool>(nullptr, "UKismetSystemLibrary.MoveComponentTo", Component, TargetRelativeLocation, TargetRelativeRotation, bEaseOut, bEaseIn, OverTime, MoveAction, LatentInfo, bSweep); }
	static void QuitGame(UObject * WorldContextObject, APlayerController * SpecificPlayer, TEnumAsByte<enum EQuitPreference::Type> QuitPreference) { NativeCall<void, UObject *, APlayerController *, TEnumAsByte<enum EQuitPreference::Type>>(nullptr, "UKismetSystemLibrary.QuitGame", WorldContextObject, SpecificPlayer, QuitPreference); }
	static void RetriggerableDelay(UObject * WorldContextObject, float Duration, FLatentActionInfo LatentInfo) { NativeCall<void, UObject *, float, FLatentActionInfo>(nullptr, "UKismetSystemLibrary.RetriggerableDelay", WorldContextObject, Duration, LatentInfo); }
	static void SetBoolPropertyByName(UObject * Object, FName PropertyName, bool Value) { NativeCall<void, UObject *, FName, bool>(nullptr, "UKismetSystemLibrary.SetBoolPropertyByName", Object, PropertyName, Value); }
	static void SetBytePropertyByName(UObject * Object, FName PropertyName, char Value) { NativeCall<void, UObject *, FName, char>(nullptr, "UKismetSystemLibrary.SetBytePropertyByName", Object, PropertyName, Value); }
	static void SetClassPropertyByName(UObject * Object, FName PropertyName, TSubclassOf<UObject> Value) { NativeCall<void, UObject *, FName, TSubclassOf<UObject>>(nullptr, "UKismetSystemLibrary.SetClassPropertyByName", Object, PropertyName, Value); }
	static void SetDoublePropertyByName(UObject * Object, FName PropertyName, long double Value) { NativeCall<void, UObject *, FName, long double>(nullptr, "UKismetSystemLibrary.SetDoublePropertyByName", Object, PropertyName, Value); }
	static void SetFloatPropertyByName(UObject * Object, FName PropertyName, float Value) { NativeCall<void, UObject *, FName, float>(nullptr, "UKismetSystemLibrary.SetFloatPropertyByName", Object, PropertyName, Value); }
	static void SetIntPropertyByName(UObject * Object, FName PropertyName, int Value) { NativeCall<void, UObject *, FName, int>(nullptr, "UKismetSystemLibrary.SetIntPropertyByName", Object, PropertyName, Value); }
	static void SetLinearColorPropertyByName(UObject * Object, FName PropertyName, const FLinearColor * Value) { NativeCall<void, UObject *, FName, const FLinearColor *>(nullptr, "UKismetSystemLibrary.SetLinearColorPropertyByName", Object, PropertyName, Value); }
	static void SetNamePropertyByName(UObject * Object, FName PropertyName, const FName * Value) { NativeCall<void, UObject *, FName, const FName *>(nullptr, "UKismetSystemLibrary.SetNamePropertyByName", Object, PropertyName, Value); }
	static void SetObjectPropertyByName(UObject * Object, FName PropertyName, UObject * Value) { NativeCall<void, UObject *, FName, UObject *>(nullptr, "UKismetSystemLibrary.SetObjectPropertyByName", Object, PropertyName, Value); }
	static void SetRotatorPropertyByName(UObject * Object, FName PropertyName, const FRotator * Value) { NativeCall<void, UObject *, FName, const FRotator *>(nullptr, "UKismetSystemLibrary.SetRotatorPropertyByName", Object, PropertyName, Value); }
	static void SetStringPropertyByName(UObject * Object, FName PropertyName, const FString * Value) { NativeCall<void, UObject *, FName, const FString *>(nullptr, "UKismetSystemLibrary.SetStringPropertyByName", Object, PropertyName, Value); }
	static void SetSupressViewportTransitionMessage(UObject * WorldContextObject, bool bState) { NativeCall<void, UObject *, bool>(nullptr, "UKismetSystemLibrary.SetSupressViewportTransitionMessage", WorldContextObject, bState); }
	static void SetTextPropertyByName(UObject * Object, FName PropertyName, const FText * Value) { NativeCall<void, UObject *, FName, const FText *>(nullptr, "UKismetSystemLibrary.SetTextPropertyByName", Object, PropertyName, Value); }
	static void SetTransformPropertyByName(UObject * Object, FName PropertyName, const FTransform * Value) { NativeCall<void, UObject *, FName, const FTransform *>(nullptr, "UKismetSystemLibrary.SetTransformPropertyByName", Object, PropertyName, Value); }
	static void SetVectorPropertyByName(UObject * Object, FName PropertyName, const FVector * Value) { NativeCall<void, UObject *, FName, const FVector *>(nullptr, "UKismetSystemLibrary.SetVectorPropertyByName", Object, PropertyName, Value); }
	static void ShowAdBanner(bool bShowOnBottomOfScreen) { NativeCall<void, bool>(nullptr, "UKismetSystemLibrary.ShowAdBanner", bShowOnBottomOfScreen); }
	static void ShowPlatformSpecificAchievementsScreen(APlayerController * SpecificPlayer) { NativeCall<void, APlayerController *>(nullptr, "UKismetSystemLibrary.ShowPlatformSpecificAchievementsScreen", SpecificPlayer); }
	static void ShowPlatformSpecificLeaderboardScreen(const FString * CategoryName) { NativeCall<void, const FString *>(nullptr, "UKismetSystemLibrary.ShowPlatformSpecificLeaderboardScreen", CategoryName); }
	static bool SphereOverlapActorsSimple(UObject * WorldContextObject, const FVector SpherePos, float SphereRadius, TEnumAsByte<enum EObjectTypeQuery> ObjectType, UClass * ActorClassFilter, const TArray<AActor *> * ActorsToIgnore, TArray<AActor *> * OutActors) { return NativeCall<bool, UObject *, const FVector, float, TEnumAsByte<enum EObjectTypeQuery>, UClass *, const TArray<AActor *> *, TArray<AActor *> *>(nullptr, "UKismetSystemLibrary.SphereOverlapActorsSimple", WorldContextObject, SpherePos, SphereRadius, ObjectType, ActorClassFilter, ActorsToIgnore, OutActors); }
	static bool SphereOverlapActors_DEPRECATED(UObject * WorldContextObject, const FVector SpherePos, float SphereRadius, EOverlapFilterOption Filter, UClass * ActorClassFilter, const TArray<AActor *> * ActorsToIgnore, TArray<AActor *> * OutActors) { return NativeCall<bool, UObject *, const FVector, float, EOverlapFilterOption, UClass *, const TArray<AActor *> *, TArray<AActor *> *>(nullptr, "UKismetSystemLibrary.SphereOverlapActors_DEPRECATED", WorldContextObject, SpherePos, SphereRadius, Filter, ActorClassFilter, ActorsToIgnore, OutActors); }
	static bool SphereOverlapActors_NEW(UObject * WorldContextObject, const FVector SpherePos, float SphereRadius, const TArray<TEnumAsByte<enum EObjectTypeQuery>> * ObjectTypes, UClass * ActorClassFilter, const TArray<AActor *> * ActorsToIgnore, TArray<AActor *> * OutActors) { return NativeCall<bool, UObject *, const FVector, float, const TArray<TEnumAsByte<enum EObjectTypeQuery>> *, UClass *, const TArray<AActor *> *, TArray<AActor *> *>(nullptr, "UKismetSystemLibrary.SphereOverlapActors_NEW", WorldContextObject, SpherePos, SphereRadius, ObjectTypes, ActorClassFilter, ActorsToIgnore, OutActors); }
	static bool SphereOverlapComponents_DEPRECATED(UObject * WorldContextObject, const FVector SpherePos, float SphereRadius, EOverlapFilterOption Filter, UClass * ComponentClassFilter, const TArray<AActor *> * ActorsToIgnore, TArray<UPrimitiveComponent *> * OutComponents) { return NativeCall<bool, UObject *, const FVector, float, EOverlapFilterOption, UClass *, const TArray<AActor *> *, TArray<UPrimitiveComponent *> *>(nullptr, "UKismetSystemLibrary.SphereOverlapComponents_DEPRECATED", WorldContextObject, SpherePos, SphereRadius, Filter, ComponentClassFilter, ActorsToIgnore, OutComponents); }
	static bool SphereOverlapComponents_NEW(UObject * WorldContextObject, const FVector SpherePos, float SphereRadius, const TArray<TEnumAsByte<enum EObjectTypeQuery>> * ObjectTypes, UClass * ComponentClassFilter, const TArray<AActor *> * ActorsToIgnore, TArray<UPrimitiveComponent *> * OutComponents) { return NativeCall<bool, UObject *, const FVector, float, const TArray<TEnumAsByte<enum EObjectTypeQuery>> *, UClass *, const TArray<AActor *> *, TArray<UPrimitiveComponent *> *>(nullptr, "UKismetSystemLibrary.SphereOverlapComponents_NEW", WorldContextObject, SpherePos, SphereRadius, ObjectTypes, ComponentClassFilter, ActorsToIgnore, OutComponents); }
	static bool SphereTraceMultiByObject_DEPRECATED(UObject * WorldContextObject, const FVector Start, const FVector End, float Radius, const TArray<TEnumAsByte<enum ECollisionChannel>> * ObjectsToTrace, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, TArray<FHitResult> * OutHits, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, float, const TArray<TEnumAsByte<enum ECollisionChannel>> *, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, TArray<FHitResult> *, bool>(nullptr, "UKismetSystemLibrary.SphereTraceMultiByObject_DEPRECATED", WorldContextObject, Start, End, Radius, ObjectsToTrace, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHits, bIgnoreSelf); }
	static bool SphereTraceMultiForObjects(UObject * WorldContextObject, const FVector Start, const FVector End, float Radius, const TArray<TEnumAsByte<enum EObjectTypeQuery>> * ObjectTypes, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, TArray<FHitResult> * OutHits, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, float, const TArray<TEnumAsByte<enum EObjectTypeQuery>> *, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, TArray<FHitResult> *, bool>(nullptr, "UKismetSystemLibrary.SphereTraceMultiForObjects", WorldContextObject, Start, End, Radius, ObjectTypes, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHits, bIgnoreSelf); }
	static bool SphereTraceMulti_DEPRECATED(UObject * WorldContextObject, const FVector Start, const FVector End, float Radius, ECollisionChannel TraceChannel, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, TArray<FHitResult> * OutHits, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, float, ECollisionChannel, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, TArray<FHitResult> *, bool>(nullptr, "UKismetSystemLibrary.SphereTraceMulti_DEPRECATED", WorldContextObject, Start, End, Radius, TraceChannel, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHits, bIgnoreSelf); }
	static bool SphereTraceMulti_NEW(UObject * WorldContextObject, const FVector Start, const FVector End, float Radius, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, TArray<FHitResult> * OutHits, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, float, ETraceTypeQuery, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, TArray<FHitResult> *, bool>(nullptr, "UKismetSystemLibrary.SphereTraceMulti_NEW", WorldContextObject, Start, End, Radius, TraceChannel, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHits, bIgnoreSelf); }
	static bool SphereTraceSingleByObject_DEPRECATED(UObject * WorldContextObject, const FVector Start, const FVector End, float Radius, const TArray<TEnumAsByte<enum ECollisionChannel>> * ObjectsToTrace, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, FHitResult * OutHit, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, float, const TArray<TEnumAsByte<enum ECollisionChannel>> *, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, FHitResult *, bool>(nullptr, "UKismetSystemLibrary.SphereTraceSingleByObject_DEPRECATED", WorldContextObject, Start, End, Radius, ObjectsToTrace, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHit, bIgnoreSelf); }
	static bool SphereTraceSingleForObjects(UObject * WorldContextObject, const FVector Start, const FVector End, float Radius, const TArray<TEnumAsByte<enum EObjectTypeQuery>> * ObjectTypes, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, FHitResult * OutHit, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, float, const TArray<TEnumAsByte<enum EObjectTypeQuery>> *, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, FHitResult *, bool>(nullptr, "UKismetSystemLibrary.SphereTraceSingleForObjects", WorldContextObject, Start, End, Radius, ObjectTypes, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHit, bIgnoreSelf); }
	static bool SphereTraceSingle_DEPRECATED(UObject * WorldContextObject, const FVector Start, const FVector End, float Radius, ECollisionChannel TraceChannel, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, FHitResult * OutHit, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, float, ECollisionChannel, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, FHitResult *, bool>(nullptr, "UKismetSystemLibrary.SphereTraceSingle_DEPRECATED", WorldContextObject, Start, End, Radius, TraceChannel, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHit, bIgnoreSelf); }
	static bool SphereTraceSingle_NEW(UObject * WorldContextObject, const FVector Start, const FVector End, float Radius, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<AActor *> * ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, FHitResult * OutHit, bool bIgnoreSelf) { return NativeCall<bool, UObject *, const FVector, const FVector, float, ETraceTypeQuery, bool, const TArray<AActor *> *, EDrawDebugTrace::Type, FHitResult *, bool>(nullptr, "UKismetSystemLibrary.SphereTraceSingle_NEW", WorldContextObject, Start, End, Radius, TraceChannel, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHit, bIgnoreSelf); }
	static void StackTraceImpl(const FFrame * StackFrame) { NativeCall<void, const FFrame *>(nullptr, "UKismetSystemLibrary.StackTraceImpl", StackFrame); }
	static void SwitchNetworkMode(UObject * WorldContextObject, TEnumAsByte<enum ENetModeBP::Type> * OutNetworkMode) { NativeCall<void, UObject *, TEnumAsByte<enum ENetModeBP::Type> *>(nullptr, "UKismetSystemLibrary.SwitchNetworkMode", WorldContextObject, OutNetworkMode); }
};

